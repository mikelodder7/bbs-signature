{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-01-27T00:08:18.813895+00:00",
  "repo": "decentralized-identity/bbs-signature",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "current-signature-specification",
      "description": "Issues associated to the current BBS signature specification that previous implementations used",
      "color": "185E2C"
    },
    {
      "name": "ready-for-pr",
      "description": "",
      "color": "CD2B82"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU5OTUxOTA5Mzg=",
      "title": "Update specification to document the usage of hash 2 curve draft 6",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/1",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "current-signature-specification"
      ],
      "body": "Current implementations of BBS signatures are using hash 2 curve draft 6, this should be noted in the document for those wanting to build interoperable implementations as subsequent revisions of the hash 2 curve draft have been breaking.",
      "createdAt": "2021-09-13T18:20:38Z",
      "updatedAt": "2021-09-13T18:20:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead",
          "createdAt": "2021-09-13T18:20:54Z",
          "updatedAt": "2021-09-13T18:20:54Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU5OTUxOTM5OTg=",
      "title": "Document the binary formats for cryptographic structures defined by the specification",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/2",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "current-signature-specification"
      ],
      "body": "Within the draft there are several new cryptographic structures that are encoded in binary, their format should be documented to support interoperable implementations, these include\r\n\r\n- ProofOfKnowledge (signature proof)\r\n- Commitment\r\n- Commitment ProofOfKnowledge\r\n- BBS Signature",
      "createdAt": "2021-09-13T18:24:25Z",
      "updatedAt": "2022-01-26T17:30:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead",
          "createdAt": "2021-09-13T18:24:44Z",
          "updatedAt": "2021-09-13T18:24:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "A topic for future discussion is whether to use a structured (e.g CBOR) vs custom binary format, current implementations use a custom binary format however structured solutions like CBOR could be considered for future revisions.",
          "createdAt": "2021-09-13T18:28:59Z",
          "updatedAt": "2021-09-13T18:28:59Z"
        },
        {
          "author": "ChristopherA",
          "authorAssociation": "NONE",
          "body": "I\u2019m hoping you document CBOR versions of these (and not the IPFS version of CBOR). We are increasingly using CBOR in wallet interoperability standards as it allows airgap solutions like UR: \r\n\r\n* https://github.com/BlockchainCommons/crypto-commons#urs\r\n* https://github.com/BlockchainCommons/Research/blob/master/papers/bcr-2020-005-ur.md",
          "createdAt": "2021-10-05T03:12:53Z",
          "updatedAt": "2021-10-05T03:12:53Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we will want to reference the [pairing-friendly curves](https://www.ietf.org/archive/id/draft-irtf-cfrg-pairing-friendly-curves-10.html#name-zcash-serialization-format-) RFC at least for BLS12-381. It is supposedly undergoing changes to make the draft more normative (and hopefully move beyond a draft). We would probably want to have each profile specify the binary encoding for scalars and group elements for its related pairing-friendly curve, and then define things like the signature binary format on top of that.",
          "createdAt": "2022-01-26T17:29:42Z",
          "updatedAt": "2022-01-26T17:30:04Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU5OTUyMDE3MDM=",
      "title": "Seperate the message generators from the public key",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/3",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "current-signature-specification"
      ],
      "body": "Currently the specification uses the term \"deterministic public key\" to refer to the underlying public key + message generators required to commit a series of messages to in order to construct a BBS signature signed by an issuer. This association has been found to be confusing and the suggested clarification is to remove the concept of a \"deterministic public key\" and instead just have a public key and a set of message generators with a defined process under which they are generated.",
      "createdAt": "2021-09-13T18:34:21Z",
      "updatedAt": "2022-01-13T01:28:38Z",
      "closedAt": "2022-01-13T01:28:38Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Closing in favour of #19 which has more elaboration on the alternatives to explore",
          "createdAt": "2022-01-13T01:28:31Z",
          "updatedAt": "2022-01-13T01:28:31Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "MDU6SXNzdWU5OTUyMDYxNjM=",
      "title": "Elaborate on background around group signatures",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/4",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Because the concept of a \"group signature\" is a lesser known term in the wider community that uses digital signature technology it would provide a good opportunity for education around some of the novel features of these types of cryptographic schemes provide if the spec included some of this background",
      "createdAt": "2021-09-13T18:40:14Z",
      "updatedAt": "2021-09-13T18:40:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7",
          "createdAt": "2021-09-13T18:40:41Z",
          "updatedAt": "2021-09-13T18:40:41Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU5OTUyMDkwMDI=",
      "title": "Change digest algorithm used to SHAKE256",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/5",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There are three different ways a digest algorithm is used in a BBS Signature\r\n\r\n1. Message generators\r\n2. Doing deterministic signature generation\r\n3. Proof - for the fiat shamir heuristic\r\n\r\nCurrent implementations use BLAKE2B however this is a non-NIST approved digest algorithm making alignment more difficult the suggestion is to shift to using SHAKE256 for the above applications",
      "createdAt": "2021-09-13T18:44:02Z",
      "updatedAt": "2021-09-13T18:44:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWU5OTUyMTYxMzU=",
      "title": "How to map data to be cryptographically signable",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/6",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Describe the process for how to map abitrary data to be in a sign-able form.\r\n\r\nThe current way in which this is done is the data is hashed and the first 48 bytes are used, this is then reduced to the first sub-group order, _mod Q_.\r\n\r\nIn future there may be new options for this process:\r\n\r\n1. Hash the data (approach depended on #5) take the 64 byte output and then reduce the data to the first sub-group order, _mod Q_.\r\n2. Mapping integers - provides the basis for range proofs\r\n3. Mapping floating point numbers\r\n4. Sortable data, e.g anything that has lexiographical ordering\r\n\r\n@mikelodder7 can provide further details",
      "createdAt": "2021-09-13T18:53:57Z",
      "updatedAt": "2021-09-13T18:53:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOF8lax84781G5",
      "title": "Test vectors",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/7",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In order to facilitate interoperability this specification should contain a set of test vectors for the cryptographic structures defined",
      "createdAt": "2021-09-23T20:06:50Z",
      "updatedAt": "2021-09-23T20:06:50Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOF8lax848HfxV",
      "title": "Crypto agility",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/8",
      "state": "OPEN",
      "author": "schanzen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current draft is partially agnostic to the cryptographic details and in other parts very specific.\r\nFor example, the choice of curve is left open: https://github.com/schanzen/bbs-signature/blob/main/spec.md#choice-of-signature-primitive\r\nBut, the curve is implicitly enforced in https://github.com/schanzen/bbs-signature/blob/main/spec.md#terminology along with other primitives such as the hash functions.\r\nThis will make #7 a bit awkward to fix.\r\n\r\nI guess the specification could be very specific to only define a concrete instantiation or abstract to allow crypto agility.\r\nThe latter may require additional metadata in the objects.\r\n\r\nRelated to #5 as well. Maybe hashfunctions should be harmonized for the initial recommendation/instantiation?",
      "createdAt": "2021-09-27T20:54:15Z",
      "updatedAt": "2021-11-02T01:40:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks for raising, I agree along side the hashing algorithm as we discussed on the most recent call the underlying curve used should be left open. Could you elaborate on where in the terminology section this is currently not the case?",
          "createdAt": "2021-09-30T19:45:33Z",
          "updatedAt": "2021-09-30T19:45:33Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "Under  https://github.com/schanzen/bbs-signature/blob/main/spec.md#terminology you are defining ```dst```,  ```hash_to_curve_g1```, and ```hash_to_curve_g2``` with a parameter which is tied to BLS12-381: BLS12381G1_XMD:BLAKE2B_SSWU_RO_BBS_SIGNATURES:1_0_0 and BLS12381G1_XMD:BLAKE2B_SSWU_RO, respectively.\r\n\r\nThe ```dst``` parameter should probably be different depending on the used hash and curve and so should the algo for the hash_to_curve.",
          "createdAt": "2021-09-30T20:04:09Z",
          "updatedAt": "2021-09-30T20:04:09Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "I guess the question is if the \"BBS+ Signature Scheme\" is supposed look like https://datatracker.ietf.org/doc/html/rfc6979 where you then have specific instantiations in the test vectors: https://datatracker.ietf.org/doc/html/rfc6979#appendix-A.2.5\r\nOr if it should be more like https://www.rfc-editor.org/rfc/rfc8032 where the choice of primitives is taken away (on purpose).\r\nOne could make the argument that the approach of EdDSA is more sensible as implementors will make less errors, but maybe the scheme itself should then also be qualified. Ex: \"The BLS12-381-SHAKE-BBS+ signature scheme\" or similar.",
          "createdAt": "2021-09-30T20:17:57Z",
          "updatedAt": "2021-09-30T20:20:39Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "> One could make the argument that the approach of EdDSA is more sensible as implementors will make less errors...\r\n\r\n+1 to this approach.",
          "createdAt": "2021-10-04T21:27:57Z",
          "updatedAt": "2021-10-04T21:27:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Yeah +1 being overly cryptographically agile is a security and implementation risk, I would suggest the best middle ground is to position the draft with a single definition of DIGEST_ALGORITHM / HASH_ALGORITHM rather than having the concrete algorithm repeated throughout as it is currently.",
          "createdAt": "2021-10-07T20:09:57Z",
          "updatedAt": "2021-10-07T20:09:57Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "Yeah, it's one thing to make sure your core design is flexible and pluggable. It's another thing to surface that flexibility all the way up your stack to implementers/users that can make bad mistakes with the wrong choices. Eliminate choice at those top layers to help protect implementers/users.",
          "createdAt": "2021-10-07T22:15:28Z",
          "updatedAt": "2021-10-07T22:15:28Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "The other point I was trying to make is that the \"name\" of the draft is currently very generic \"BBS Signature Scheme\" while what is proposed is actually much more specific. It may be time to give the proposed scheme a dedicated (new) name? My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up.",
          "createdAt": "2021-10-08T08:16:25Z",
          "updatedAt": "2021-10-08T08:16:25Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up\r\n\r\nI think this is asking another cryptographic agility question here seperate from the selection of the digest algorithm, which is should the draft couple itself to a particular pairing based curve (e.g BLS 12-381). The decision to mandate a particular digest algorithm does not necessarily mean we have to do the same in regards to the curve. Leaving the draft open to new curves makes it more like ECDSA rather than EdDSA in this respect. ",
          "createdAt": "2021-10-10T20:44:14Z",
          "updatedAt": "2021-10-10T20:44:14Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "> > My reasoning is that it basically squats the concept of \"BBS+ Signature Schemes\" which may lead to confusion in the future especially of schemes based on other curves pop up\r\n> \r\n> I think this is asking another cryptographic agility question here seperate from the selection of the digest algorithm, which is should the draft couple itself to a particular pairing based curve (e.g BLS 12-381). The decision to mandate a particular digest algorithm does not necessarily mean we have to do the same in regards to the curve. Leaving the draft open to new curves makes it more like ECDSA rather than EdDSA in this respect.\r\n\r\nThe (albeit theoretical) issue I have with \"BBS Signature Scheme\" is that this specifier existed before this (more specific) draft. So if anybody ever writes down \"We are using the BBS Signature Scheme\" it is ambiguous if this refers to any implementation of the proposed scheme from a paper or this specific proposal. On the other hand is is 100% unambiguous if somebody writes ECDSA or EdDSA, respectively. There is only one way to do those, and they can be found in RFCs. The issue is that the draft is using a name which is, essentially, already \"taken\" and that may lead to issues unless this becomes **the** de-facto standard and \"overtaking\" the meaning of \"BBS Signatures\" which cannot be guaranteed.\r\n\r\nTo be more specific:\r\n1. \"BBS Signature\" is defined here: D. Boneh, X. Boyen, and H. Shacham. Short Group Signatures.\r\n2. \"BBS+ Signature\" is defined here: Man Ho Au, Willy Susilo, and Yi Mu. Constant-Size Dynamic k-TAA.\r\n\r\nWhat is written in the draft/specification in this repos is \"XYZ Signature Scheme\" which is _based on a_ BBS (1) or BBS+ (2) signature.\r\n",
          "createdAt": "2021-10-11T10:36:36Z",
          "updatedAt": "2021-10-11T10:56:37Z"
        },
        {
          "author": "schanzen",
          "authorAssociation": "NONE",
          "body": "Just adding here a point raised by @tplooker in today's meeting: The wip draft (#3) conceptually deviates from the one proposed in the papers with respect to the deterministic generation of message commitments. Which makes the draft even more a variation of BBS which uses/proposes the use of nonce values.",
          "createdAt": "2021-10-11T20:31:24Z",
          "updatedAt": "2021-10-11T20:32:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "During the delayed call today we discussed taking this draft in the direction of supporting several key cryptographic extension points, e.g \"agile\". And then defining profiles on top which promote interoperable implementations. \r\n\r\nSome of the rational for this was noted through how elliptic curve cryptography was developed, essentially ECDSA when it was developed preceded formal standardisation of particular elliptic curves, hence the need to remain agnostic. Within the sub-field of pairing cryptography we find a similar situation where by multiple curves are showing promise and adoption however innovation and development continue to occur here. Therefore rather than the draft picking one winner, a set of security criteria could be defined that allows different pairing friendly curves to be used.\r\n\r\nGoing in this direction with the draft would mean the follow elements would be abstractly defined\r\n- The hash algorithm\r\n- The pairing friendly curve",
          "createdAt": "2021-11-02T01:40:06Z",
          "updatedAt": "2021-11-02T01:40:06Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOF8lax8480yF_",
      "title": "Proof of knowledge revealed message structure",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/10",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Related to #2 \r\n\r\nCurrently the implementations of a BBS proof of knowledge signature includes the encoding of a binary structure at the start of the proof which captures which of the messages being verified and how they correspond to the original ordering of the message set signed. Currently this structure takes the form of a bit array.\r\n\r\nFor example assume the following set of messages were originally signed\r\n\r\n```\r\n[\r\n  \"message1\"\r\n  \"message2\",\r\n  \"message3\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nAnd a proof revealing only the 1st 4th and 5th message was generated, meaning the revealed messages supplied during the verify proof operation would appear in the following order\r\n\r\n```\r\n[\r\n  \"message1\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nThe resulting bit array in the proof would take the following form\r\n\r\n```\r\n+-----------------------------+-----------------------------+---------------------------------+\r\n| Total messages length (16bit)| Revealed messages bit array |..... remaining proof structure |\r\n+-----------------------------+-----------------------------+---------------------------------+\r\n\r\n+-----------+--------------+-----------------------------------+\r\n| 5 (integer) | 1 | 0 | 0 | 1 | 1  | ..... remaining proof structure |\r\n+-----------+--------------+-----------------------------------+\r\n```\r\n\r\nHowever, this mechanism of expression does limit options around the data canonicalisation algorithm that is used on top of the cryptographic scheme. Namely it does not support a re-ordering of the revealed messages away from the order in which they were originally signed. To accomodate this we could instead elect to change the expression of this aspect of the proof from a bit array to a byte/multi-byte array, where instead the array contents is a set of un-signer integers (16bit each) where each integer corresponds to the index the message occupied in the original ordering of the signed message set\r\n\r\nFor example assume the following set of messages were originally signed\r\n\r\n```\r\n[\r\n  \"message1\",\r\n  \"message2\",\r\n  \"message3\",\r\n  \"message4\",\r\n  \"message5\"\r\n]\r\n```\r\n\r\nAnd a proof revealing only the 1st 4th and 5th message was generated, **BUT** the messages in the resulting proof are re-ordered so that they present as 4, 5, 1 \r\n\r\n```\r\n[\r\n  \"message4\",\r\n  \"message5\",\r\n  \"message1\"\r\n]\r\n```\r\n\r\nThe resulting bit array in the proof would take the following form\r\n\r\n```\r\n+-----------------------------+----------------------------------------+-------------------------------+----------------+\r\n| Total messages length (16bit)| Revealed messages array length (16bit) | Revealed messages byte array | remaining proof |\r\n+-----------------------------+----------------------------------------+-------------------------------+----------------+\r\n\r\n+--+--+--------+------------------------------+\r\n| 5  | 3 | 4 | 5 | 1 | ..... remaining proof structure |\r\n+--+--+--------+------------------------------+\r\n```\r\n\r\nThe tradeoff here is that the overhead of this structure is more than in the simpler case with the bit array.\r\n\r\n**NOTE** It is probably also worth considering a more standard structured binary format like CBOR rather than a custom structure ",
      "createdAt": "2021-10-07T21:15:45Z",
      "updatedAt": "2022-01-23T19:45:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> Namely it does not support a re-ordering of the revealed messages away from the order in which they were originally signed.\r\n\r\nCould you expand on this some? I'm missing the context of why canonicalization would force the messages to be ordered differently, in any approach the original index must be preserved so why can't they be correctly re-ordered before being serialized?",
          "createdAt": "2021-10-07T21:29:33Z",
          "updatedAt": "2021-10-07T21:29:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@quartzjer good question, An example is RDF Dataset normalisation, when you have a graph that features several blank nodes, and then you create a sub-graph from this (e.g your sub-set of revealed messages). The ordering of the \"statements\" in the canonical form of the sub-graph can be different to that of the original graph.",
          "createdAt": "2021-10-07T21:47:45Z",
          "updatedAt": "2021-10-07T21:47:45Z"
        },
        {
          "author": "OR13",
          "authorAssociation": "NONE",
          "body": "@quartzjer its related to graph isomorphism and canonicalization of derived subgraphs... basically, the derive operation is an object transformation... (graph 1 -> graph 2).\r\n\r\n```\r\ngraph 1 -> [messages order that is signed over]\r\ngraph 2 -> [messages order can be different]\r\n```\r\n\r\nThis a problem because of the compact use of hash to point... the order is exploited to make the proof compact... we can't do that with merkle proofs, which is part of why the proof size is so much larger... ",
          "createdAt": "2021-10-07T21:52:20Z",
          "updatedAt": "2021-10-07T21:52:20Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "That context is helpful and makes sense.  It does still seem a bit odd to me though, adding metadata that doesn't directly impact/support the crypto methods and is intended to work around a limitation of a higher layer.\r\n\r\nMore troublesome though, it also exposes a correlation vector.  How the revealed messages are re-ordered by the canonicalization leaks some information about the original ordering of the non-revealed messages.  It may seem like a small leak, but all leaks can be exploited once you have enough data.",
          "createdAt": "2021-10-07T22:12:15Z",
          "updatedAt": "2021-10-07T22:12:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "I think the meta-question here is what constraints does the cryptographic layer impose around what canonicalisation algorithms can be used above it.\r\n\r\n> More troublesome though, it also exposes a correlation vector. How the revealed messages are re-ordered by the canonicalization leaks some information about the original ordering of the non-revealed messages. It may seem like a small leak, but all leaks can be exploited once you have enough data.\r\n\r\nYes this is a valid point, however its important to note its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information, that aspect IMO could be addressed via privacy/security considerations. ",
          "createdAt": "2021-10-08T01:24:58Z",
          "updatedAt": "2021-10-08T01:24:58Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information\r\n\r\nIt is actually guaranteed, even just simply the fact that they are re-ordered is a leak having nothing to do with the algorithm that does it.  If the issuer and the holder use different ordering, it's a vector to exploit.\r\n\r\n> that aspect IMO could be addressed via privacy/security considerations.\r\n\r\nSure, I just get uncomfortable seeing that adding built-in support for re-ordered indexes increases linkability (if used). ",
          "createdAt": "2021-10-08T15:51:37Z",
          "updatedAt": "2021-10-08T15:51:37Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This issue is only coming about because the input to the signature in this situation is a set of statements with their own independent ordering (the n-quads). To me that seems outside of the scope of the signature method itself, in that it could easily be handled at a higher layer by providing additional input mapping the statement order to the signed message order, or by manually reordering the statements. In fact I did not expect us to define an encoding for the revealed message indices at all, again leaving that up to concrete implementations (the LD-proof in this case).",
          "createdAt": "2021-10-08T16:02:57Z",
          "updatedAt": "2021-10-08T16:02:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "This conversation has been great to draw out the different possible design options we can accomodate at the cryptographic layer for BBS signatures.\r\n\r\n1. The structure for a BBS proof of knowledge is defined in a way that it features no information about which of the revealed messages correspond to in the order in which they were originally signed (required to be able to do a verify proof operation). This would mean verify proof would require a new seperate argument to be supplied alongside the public key proof and revealed message set.\r\n2. The structure for a BBS proof of knowledge is defined in a way that features a preceding bit array where each bit of the array indicates where the message was revealed or not. This means the revealed message set MUST be ordered in the same order as it was originally signed (with un-revealed messages simply removed).\r\n3.  The structure for a BBS proof of knowledge is defined in a way that features a preceding byte array, which is essentially the proposal at the start of this issue.",
          "createdAt": "2021-10-10T20:18:07Z",
          "updatedAt": "2021-10-10T20:18:07Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "@tplooker,\r\n\r\nIs this issue related at all to a discussion we had about introducing the use of an HMAC key (that remains secret to both the issuer and holder, i.e., never shared with any verifier) that is used to generate blank node IDs prior to signing -- to fully obscure any information about how those IDs were chosen (i.e., no matter how the canonicalization algorithm works, the IDs would appear random to verifiers)?",
          "createdAt": "2021-10-18T15:42:30Z",
          "updatedAt": "2021-10-18T15:42:30Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@dlongley yes more specifically my comment here\r\n\r\n> Yes this is a valid point, however its important to note its not guaranteed that the algorithm for re-ordering the revealed messages will actually leak information, that aspect IMO could be addressed via privacy/security considerations.\r\n\r\nOtherwise in general the issue is discussing more broadly what mechanisms should be at the cryptographic layer vs deferred to higher layers.",
          "createdAt": "2021-10-20T19:06:33Z",
          "updatedAt": "2021-10-20T19:06:33Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "Could someone (perhaps @tplooker or @brianorwhatever?) provide an example (the simplest possible) of a JSON-LD VC that cannot be verified using BBS+, annotating it with how the problem manifests? I'm trying to understand the scope of the issue, and especially, the scope in real world use cases.  Is it anytime that nesting is used, or is it a certain pattern of nesting?  How can a non-JSON-LD person understand the impact?\r\n\r\nThanks!",
          "createdAt": "2021-11-17T19:48:44Z",
          "updatedAt": "2021-11-17T19:48:44Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "@swcurran I would take a look at @tplooker comment here https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issuecomment-945238151 for the most succint description of the problem. My impression is that it is basically going to happen whenever there is nested objects (unsure how many will trigger it) within the `credentialSubject` that don't have an `id` attribute",
          "createdAt": "2021-11-18T00:59:26Z",
          "updatedAt": "2021-11-18T00:59:26Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "It's helpful but not an example of the JSON-LD that triggers the issue. However, [your comment in that same issue](https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issue-1005912071) has an example.\r\n\r\nAs I understand @tplooker's explanation that [you reference](https://github.com/mattrglobal/jsonld-signatures-bbs/issues/158#issuecomment-945238151), the issue manifests in your credential by the existence of the `recipient` and `vaccine` items with no `id` below them.  Presumably, if you had just one item, or all (or all but one) had an `id`, life would be good. And presumably, anytime there is more than one such item anywhere in the JSON will trigger the problem.\r\n\r\nThat's going to be pretty rough for anyone that wants to use an existing structure as a VC.\r\n\r\n",
          "createdAt": "2021-11-18T01:29:21Z",
          "updatedAt": "2021-11-18T01:29:21Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@swcurran The problem is related to, but not directly caused, by the serialization algorithm (i.e., URDNA). The problem in the example is caused by the way the Holder communicated the indexes of the revealed messages to the Verifier, because it does not account for the fact that the messages received by the Verifier may not be in the same order that the Holder has them (because of URDNA).\r\n\r\nAs an example, let\u2019s say that the Holder has messages `m1`, `m2` and `m3` and creates a proof disclosing only `m2` and `m3`. What was proposed to let the Verifier know what messages are disclosed, is that the Holder will also send the bit array `011` indicating that they have 3 messages and that they disclosed the 2nd and the 3rd one. However, if the Verifier gets the messages as `[m3, m2]` (correct messages, wrong order) they will use `m3` like it was the 2nd Holder\u2019s message and `m2` like it was the third. That miss-match will make the verification fail. \r\n\r\nThe solution however is not to put `id's` to every nested object in the VC (although that could also work). The simple solution is to communicate the indexes of the revealed messages in a way that will account for the case above. One way to do that is instead of the Holder sending the bit array `011` to send the integers list `[3, 2]` which solves that problem.",
          "createdAt": "2021-12-02T11:20:46Z",
          "updatedAt": "2021-12-02T11:20:46Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "Thanks.  Agree that what you state is the \"simple solution\", but in reality that means agreeing on the exact simple solution, publishing it as a new signature scheme, updating libraries and then updating the existing applications that use those libraries so that arbitrary JSON-LD can be used. That would suggest a long delay in being able to use of BBS+ credentials for general use cases.  Thus, I agree that adding in IDs is not the correct solution, it is a practical hack that will work for the existing scheme.\r\n\r\nI noticed, for example, that in publishing the BBS+ version of the mDL schema, that approach was used throughout.",
          "createdAt": "2021-12-02T17:41:28Z",
          "updatedAt": "2021-12-02T17:41:28Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "do you have a link to the bbs+ mdl schema @swcurran? sounds interesting!",
          "createdAt": "2021-12-02T18:45:51Z",
          "updatedAt": "2021-12-02T18:45:51Z"
        },
        {
          "author": "swcurran",
          "authorAssociation": "NONE",
          "body": "You can follow the chain to see the approach.  Start here: https://digitalbazaar.github.io/vdl-test-suite/ (Manu posted about this in the W3C CCG).  From the examples, the context for a \"vDL\" is https://w3id.org/vdl/v1, which resolves to a chunk of JSON that has just has an id for each attribute in the form of:\r\n\r\n``` jsonc\r\n       ...\r\n        \"family_name\": {\r\n          \"@id\": \"https://w3id.org/vdl#family_name\"\r\n        },\r\n        \"given_name\": {\r\n          \"@id\": \"https://w3id.org/vdl#given_name\"\r\n        },\r\n        \"birth_date\": {\r\n          \"@id\": \"https://w3id.org/vdl#birth_date\"\r\n        },\r\n        ...\r\n```\r\n\r\nI don't know a lot about JSON-LD and perhaps those @id's per attribute are normal.  But I would image they don't contribute much to the semantic understanding (human or machine) of the attributes -- but they do provide an ID.\r\n\r\n",
          "createdAt": "2021-12-02T19:29:18Z",
          "updatedAt": "2021-12-02T19:29:18Z"
        },
        {
          "author": "brianorwhatever",
          "authorAssociation": "NONE",
          "body": "Cool, thanks for the link. I'm also not a JSON-LD expert but I believe an `@id` is more about what the node is semantically vs an identifier (`id`) for the node which is the issue in this instance. See this example https://www.w3.org/TR/json-ld/#example-4-context-for-the-sample-document-in-the-previous-section\r\n\r\nThere's also the `\"@type\": \"@id\"` line which is often seen in contexts and I don't totally understand..",
          "createdAt": "2021-12-02T21:17:44Z",
          "updatedAt": "2021-12-02T21:17:44Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "What are the consequences if the signature specification didn't include any revealed message indexes or how they're encoded, and surrendered that responsibility to higher level application suites, like Linked Data and Jose processors. This neither adds nor removes any (more) leaks from the signature format, it's just makes it less opinionated about attaching information to the signature that isn't signed over anyway. This means each application will have to define how to handle index information and not be constrained by the signature format. I believe this is how the BBS+ LD was initially implemented, but then things got moved into the crypto encoding of the signature mostly for convenience and API design style.",
          "createdAt": "2022-01-20T20:58:51Z",
          "updatedAt": "2022-01-20T21:00:24Z"
        },
        {
          "author": "dlongley",
          "authorAssociation": "NONE",
          "body": "+1 to making the low-level signature specification (RFC dealing with the crypto specifically) not be opinionated about message indexes or how the data is encoded but instead just receive appropriately atomized / ordered data for signing. The next layer up (e.g., Data Integrity BBS+ Signature spec / JWP spec) can define how to consume / transform / canonize / order / atomize / etc. the data that is to be passed to the crypto layer.",
          "createdAt": "2022-01-20T21:54:11Z",
          "updatedAt": "2022-01-20T21:54:11Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Thanks @tmarkovski @dlongley for adding to the conversation I agree with much of the sentiment shared. In an effort to clarify further, listed below are the most relevant hard requirements BBS Signatures as a crypto scheme has that is influential in designing the contract/interface and related data structures for a derived BBS proof.\r\n\r\n- When verifying a derived BBS proof, the verifying party must know the total number of messages that were originally signed when the signature was created.\r\n- When verifying a derived BBS proof, for any revealed messages (messages that the holder or prover wishes to prove were signed by an issuer), the verifying party must know the placement each revealed message occupied in the original set of messages that were signed.\r\n\r\nFrom my understanding of the opinions shared in this issue and also via DIF slack, is that most people are supportive of a proposal where the cryptographic layer has no opinion about the message indexes leaving it to upstream technologies (e.g LD-Proof or JWP) to make this definition. This means the derived BBS proof structure defined by this draft will only describe the direct cryptographic information of the proof.\r\n\r\nGiven that proposal we still need to decide how the contract for verifying a deriveProof should change, for instance the current draft defines\r\n\r\n```\r\nresult = SpkVerify(spk, PK, (msg[i],...,msg[D]), nonce)\r\n```\r\n\r\nwhere D is the number of revealed messages makes the following invalid assumptions\r\n\r\n- spk contains information on the total number of messages originally signed\r\n- spk contains some form of mapping that maps the revealed messages (msg) to their original position in the originally signed message set.\r\n\r\nOne potential proposal would be to change the contract for verifying a derivedProof to something like\r\n\r\n```\r\nresult = SpkVerify(spk, PK, revealedMessages, totalSignedMessages, nonce)\r\n```\r\n\r\nWhere revealed messages is a map of the following structure\r\n\r\n```\r\n{\r\n  1: octet_string_msg_1,\r\n  5: octet_string_msg_5,\r\n  9: octet_string_msg_9,\r\n}\r\n```\r\n",
          "createdAt": "2022-01-21T00:18:18Z",
          "updatedAt": "2022-01-21T00:18:18Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Another option is to retain the total signed messages as a value encoded in to `spk` to reduce the need to manage it externally, however still handle the ordering of the revealed messages in the way described above, meaning the contract would look something more like \r\n\r\n```\r\nresult = SpkVerify(spk, PK, revealedMessages, nonce)\r\n```",
          "createdAt": "2022-01-21T00:22:15Z",
          "updatedAt": "2022-01-21T00:23:01Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "Is `PK` already a function of `totalSignedMessages (L)` (via `PK = DpkToPk(DPK, L)` or `PK = SkToPk(Sk, L)`)? If yes, then encoding it doesn't save much work, since the information would be needed prior to that to construct `PK`.\r\nI like your proposal with `result = SpkVerify(spk, PK, revealedMessages, totalSignedMessages, nonce)` and using a map to unambiguously describe the message input.\r\n\r\nImplementation wise, I think application suites can choose to continue to encode the signature as it is currently, by encoding the total, indexes and proof into a single field, as long as their spec is clear this is the case. That said, we may end up with `signatureValue` in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?",
          "createdAt": "2022-01-21T13:17:49Z",
          "updatedAt": "2022-01-21T13:18:31Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  That said, we may end up with signatureValue in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?\r\n\r\nUpon further investigation, the revealed messages re-ordering issue seems to be caused by IDs that are of similar format as the blank node labels IDs. This could have a simple solution (re-sorting after transforming back to blank node labels) that will allow the LD proofs to use a bit array appended to the proof value, as originally proposed [here](https://github.com/w3c-ccg/ldp-bbs2020/issues/22). This can also eliminate the dangers of a correlation because of the re-ordering of the revealed messages.\r\n\r\nThat been said, IMO the bbs+ spec should remain agnostic to the way the indexes of the revealed messages are encoded. This could lead to the proofValue having different formats between implementations; however, IMO this is not a problem. Higher level specs like JWP and LD-proofs will most likely want to use different formats for the revealed message indexes either way, because of the way they work.\r\n",
          "createdAt": "2022-01-21T23:16:40Z",
          "updatedAt": "2022-01-21T23:16:40Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> Is PK already a function of totalSignedMessages (L) (via PK = DpkToPk(DPK, L) or PK = SkToPk(Sk, L))?\r\n\r\nThanks thats a good call out, which reminded me to file #26 given the resolution to that issue I am suggesting does my proposal make more sense? e.g PK would be an ordinary public key (Note - I release this change impacts several other sections in the draft).\r\n\r\n> Implementation wise, I think application suites can choose to continue to encode the signature as it is currently, by encoding the total, indexes and proof into a single field, as long as their spec is clear this is the case.\r\n\r\nYes I think the point to clarify is that from this drafts perspective any data structure like a reveal indices array would be left to a higher level draft to define.\r\n\r\n> That said, we may end up with signatureValue in LD proof having different format than signature in JWT, because one chose to encode additional data into the signature. Is this a problem overall?\r\n\r\nGiven they are different digital signature representation formats I expect divergence at some level. So long as the core structure of any signature / proof and public key value remains structually the same upstream then I dont think we can prevent additional data structures being wrapped around them? \r\n",
          "createdAt": "2022-01-23T19:43:57Z",
          "updatedAt": "2022-01-23T19:43:57Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> That been said, IMO the bbs+ spec should remain agnostic to the way the indexes of the revealed messages are encoded. This could lead to the proofValue having different formats between implementations; however, IMO this is not a problem. Higher level specs like JWP and LD-proofs will most likely want to use different formats for the revealed message indexes either way, because of the way they work\r\n\r\n+1 I think much of the different at these representation layers is really due to different approaches to problems like data canonicalization which should remain entirely opaque to the crypto layer (the concern of this draft)",
          "createdAt": "2022-01-23T19:45:57Z",
          "updatedAt": "2022-01-23T19:45:57Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOF8lax8488ZzG",
      "title": "Improve documentation around BBS Signature message generator procedure",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/11",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The specification currently has limited detail on how an important aspect of existing implementations of BBS associated to this draft works, that is the deterministic generation of what are known as message generators (a name that perhaps should be revisited). \r\n\r\nFor context a message generator is effectively a \"public parameter\" that is used to commit a digested message that will be protected by the resulting BBS signature. All of the message generators for all of the messages are required during sign, verify, deriveProof and verifyProof (even for those messages that remain un-revealed). For implementations of BBS signatures outside / not aligned to this draft, these generators are often communicated out of band or in conjunction with the signature or proof. \r\n\r\nImplementations following this draft however derive these generators via a deterministic process from the public key during the sign, verify, deriveProof and verifyProof operations thus removing the need to manage these generators as additional public parameter information associated to the signature.\r\n\r\nThis technique/procedure should be better documented and discussed by the working group.\r\n\r\nThis issue is also partially related to #10 in the sense that it explains why the revealed messages have to be ordered in reference to how they were signed as this provides the means to associate the correct message to its generator.\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2021-10-11T09:21:48Z",
      "updatedAt": "2021-10-11T09:23:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOF8lax84_SQWk",
      "title": "Generalize the presentation proof nonce",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/15",
      "state": "OPEN",
      "author": "christianpaquin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "ready-for-pr"
      ],
      "body": "The spec currently specifies a presentation nonce to prevent replay attack, and recommends it to be a random value. I suggest we had a few details and requirements around nonce generation, to accommodate various scenarios: \r\n - For replay protections, the nonce only need to be unique, so a verifier identifier + timestamp would work (to create proofs non-interactively).\r\n - If the holder keys are held in hardware that the user only has access for a limited period of time, then making the nonce random prevents the user pre-generating proofs to be used later after the authorized period.\r\n - A BBS+ attribute credential can be used to create a digital signature on some data, disclosing a subset of the attributes. In this case, the nonce can be the digest of the signed data.\r\n\r\nI can create a PR with suggested updates.\r\n\r\n",
      "createdAt": "2021-11-23T22:03:26Z",
      "updatedAt": "2021-12-13T19:42:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with defining requirements around nonce generation. I don\u2019t understand though how the third option prevents replay attacks or pre-generated proofs (could not the adversary replay the presentation of the same disclosed attributes or pre-generate proofs for the whole credential??). I would appreciate if you could explain that part. ",
          "createdAt": "2021-11-24T20:55:48Z",
          "updatedAt": "2021-11-24T20:55:48Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "The last point is a different potential use case: digital signature on say, a document, vs. using a BBS+ credential for authn/authz. E.g., Jane is a professional engineer of company A is asked to review and sign off on the design of a project from company B. She does, and uses her work credential with attributes (name, affiliation, level, role, etc.) to sign off the document, and discloses affiliation, level, and role (e.g., \"This was signed by a level 60 engineer from the Cloud group of Company A\"); she does not disclose her name because her company doesn't want the customer to poach their employees. In this case, the challenge `c` is the hash of the document, just like in conventional electronic signatures. There isn't a replay attack in this case; since the attacker would simply present the same signed document with same signature and disclosed attributes.",
          "createdAt": "2021-11-24T21:24:04Z",
          "updatedAt": "2021-11-24T21:24:04Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As a follow up to that issue, after talking with @christianpaquin I realized I had misunderstood the proposed use case. Although there could be a higher layer spec defining credentials for signing documents, I think it would be nice to also have that use case documented in the current spec and recommend a nonce accordingly (Maybe add a nonce generation section in the security considerations??).",
          "createdAt": "2021-11-30T17:41:43Z",
          "updatedAt": "2021-11-30T17:41:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on work item call on the 15th of Dec, @christianpaquin is going to make a PR to address this issue",
          "createdAt": "2021-12-13T19:42:52Z",
          "updatedAt": "2021-12-13T19:42:52Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "I_kwDOF8lax84_viyB",
      "title": "Blinded signatures revision",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/16",
      "state": "CLOSED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As it is right now, the commitment mechanic (blinded signatures) could lead to some inconsistencies and possible forged signatures. For example, if the Issuer signs the messages `m1`, `m2`, a \"standard\" (non-blinded) signature would be, `(A, e, s)` with\r\n\r\n    A = (g0 + h0 * s + h1 * m1 + h2 * m2)*(1/(SK+e))\r\n\r\nIf the Holder commits a message `m3` using `h1`, i.e., \r\n\r\n    commit = h0 * s\u2019 + h1 * m3\r\n\r\nThe blinded signature, created by the Issuer, would be \r\n\r\n    A_blind = (commit + g0 + h0 * s + h1 * m1 + h2 * m2)*(1/(SK+e)) = \r\n      = (g0 + h0 * (s+s\u2019) + h1 * (m1+m3) + h2 * m2) * (1/(SK+e)). \r\n\r\nNotice that `(A_blind, s+s\u2019, e)` is a valid BBS+ signature in the messages `(m1+m3)` and `m2`, which is not the desired outcome and a potential forgery (`A_blind`, `s`, `s\u2019` and `e` are known to the Holder). \r\n\r\nThe main problem is that currently there is no mechanism for the Issuer to validate that the Holder does not create commitments using the same G2 elements as themself (`h1` in the example above). My proposal is (at least for now) to define a blinded signature that would only contain committed from the Holder messages.\r\n",
      "createdAt": "2021-12-02T11:17:26Z",
      "updatedAt": "2021-12-08T10:09:30Z",
      "closedAt": "2021-12-08T10:09:29Z",
      "comments": [
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is exactly why the commitment proof of knowledge needs to be verified by the issuer prior to creating a signature using the commitment.",
          "createdAt": "2021-12-04T17:13:26Z",
          "updatedAt": "2021-12-04T17:13:26Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for your answer. I had misunderstood BlindMessagesProofGen. I think we should also mention that the Issuer should check that the used generators for the commitment are not also used for the signature, (i don't think it would be obvious to an implementer). I can make a pr for that and i think we can close this issue.",
          "createdAt": "2021-12-08T10:09:29Z",
          "updatedAt": "2021-12-08T10:09:29Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "I_kwDOF8lax85ATa0V",
      "title": "More flexible default generators",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/19",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the default generators are defined using roughly the formula `hash-to-curve(PK || index || count)`, meaning that the generators are dependent on both the public key of the issuer and the number of signed messages.\r\n\r\nThere is also discussion of wanting to use a set of predetermined random generators instead of the default generators, in which case the generators would be independent of both the public key and the number of messages in the signature.\r\n\r\nIn the interest of aligning these approaches somewhat, I think it's worth considering removing the message count from the hash input, so that the default generators depend only on the public key of the issuer. This could have positive effects on performance given that all the generators could be cached up to a maximum number of signed messages.\r\n\r\nThis change might also be relevant in the case of JSON-LD credentials. In order to commit to one or more hidden messages (to implement holder binding for instance) a holder would need to have the relevant message generators. But the total number of messages is often not known at this point in the credential exchange protocol, because the JSON-LD credential itself (including the proof block?) would need to be generated and normalized first. If the generators were independent of the number of messages and the hidden messages were among the first messages (not added to the end) then this would be made possible.",
      "createdAt": "2021-12-13T18:10:00Z",
      "updatedAt": "2022-01-24T18:57:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "I'm fine if we want a different formula. As long as the inputs have sufficient entropy.",
          "createdAt": "2021-12-13T19:20:39Z",
          "updatedAt": "2021-12-13T19:20:39Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #3 ",
          "createdAt": "2022-01-10T19:15:22Z",
          "updatedAt": "2022-01-10T19:15:22Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Another option is for the message generators to be pre generated and shared globally rather than being issuer specific like the proposal above. \r\n\r\nDiscussed on 10th Jan WG call, resolved to add a section to the spec that speaks about message generator creation which will take a seed and output a list of message generators",
          "createdAt": "2022-01-10T19:32:03Z",
          "updatedAt": "2022-01-10T19:32:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead will provide a PR that defines ^ process",
          "createdAt": "2022-01-10T19:32:27Z",
          "updatedAt": "2022-01-10T19:32:27Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There was some discussion on the call around a DST for the generators. This is an extra parameter to hash-to-curve (besides the seed and message index used as input) which would separate generators used for different signing algorithms. Currently the draft specifies `BLS12381G1_XMD:BLAKE2B_SSWU_RO_BBS+_SIGNATURES:1_0_0`. I think for the next draft it might be something like `BLS12381G1_XOF:SHAKE256_SSWU_RO_BBS+_SIGNATURES:2022`. This implies that the chosen seed value should not include such information, and might be something trivial like the encoding of the words `message generators` in the common case.",
          "createdAt": "2022-01-10T22:26:07Z",
          "updatedAt": "2022-01-10T22:26:07Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "Message generators must NOT be shared globally. They must be unique per public key for the protocol to be secure",
          "createdAt": "2022-01-11T05:21:05Z",
          "updatedAt": "2022-01-11T05:21:05Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "My proposal is to use Shake256(\u201cBBS_Domain_Generators\u201d || pk || count) to seed  the Xof then draw 64 bytes for each generator  and call hash2curve on the 64 bytes. That runs must faster than the current method in Ursa and is more secure",
          "createdAt": "2022-01-11T05:26:00Z",
          "updatedAt": "2022-01-11T05:26:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 can you elaborate on the specific security concern here when using global message generators? This model would be similar to some usages of U-Prove, perhaps you could elaborate @christianpaquin.\r\n",
          "createdAt": "2022-01-11T05:54:36Z",
          "updatedAt": "2022-01-11T05:54:50Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "U Prove is a bad comparison. See  https://eprint.iacr.org/2012/298.pdf from Anna Lysyanskaya which says `UProve is not provably secure! No proof of security has been given under any reasonable assumption; and in fact, recently, Baldimtsi and Lysyanskaya [3] showed that all known approaches for proving security in the random oracle model will fail for the Brands blind signature scheme on which UProve is based, under essentially any assumption.`\r\n\r\nAs for a universal setup for BBS+, I have not seen any formal security proofs for one way or the other. Let me review the literature to see what I can find.",
          "createdAt": "2022-01-11T14:27:03Z",
          "updatedAt": "2022-01-11T14:27:03Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "As long as `h0` is different, the other `h_i` could be shared, no? This is not a U-Prove specific construct, this should work for messages built using a Pedersen commitment constructions. BBS+ and, e.g., U-Prove are not equivalent, sure, but these types of protocols have been long studied in the literature, even if there is no formal security proof (ECDSA doesn't have a security proof either...)\r\n\r\n",
          "createdAt": "2022-01-11T14:32:32Z",
          "updatedAt": "2022-01-11T14:32:32Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "To clarify: we indeed need to make sure that the spec remains secure. BBS+ has a security proof, which _is_ a great benefit, so we should be careful to keep that. Camenisch-Drijvers-Lehmann's paper use random generators. Maybe they absolutely need this to prove the security. Maybe the shared generator approach is also secure (in practice), but can't be proven. We'd be stuck with a design choice of provable security vs. efficiency.",
          "createdAt": "2022-01-11T15:09:22Z",
          "updatedAt": "2022-01-11T15:09:22Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "We\u2019ll ECDSA does have security proofs by they\u2019re wierd.\r\n\r\nSuppose we have universal generators h_i, if I commit to a value using that it will be the same for all signatures. Think same encryption same key same message problem. This is why AES and CHACHA use nonces to remove this problem. Same key, same message, different nonce means the attacker can\u2019t tell if the same message was encrypted with the same key. Nonce reuse attacks do happen.\r\n\r\nYou raise an interesting point to just have a random h_0. I\u2019ll think about that some more. In general though I still think the generators need to be context specific or domain separated ",
          "createdAt": "2022-01-11T18:30:14Z",
          "updatedAt": "2022-01-11T18:30:14Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "It'd be worthwhile to have various academic experts review the v1 spec (when ready), wherever we land. ",
          "createdAt": "2022-01-11T21:43:41Z",
          "updatedAt": "2022-01-11T21:43:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> It'd be worthwhile to have various academic experts review the v1 spec (when ready), wherever we land.\r\n\r\n+1 we will definitely seek broader review when appropriate.\r\n\r\n > To clarify: we indeed need to make sure that the spec remains secure. BBS+ has a security proof, which is a great benefit, so we should be careful to keep that. Camenisch-Drijvers-Lehmann's paper use random generators. Maybe they absolutely need this to prove the security. Maybe the shared generator approach is also secure (in practice), but can't be proven. We'd be stuck with a design choice of provable security vs. efficiency.\r\n \r\n This is IMO is core to conversation here, is the random nature in which the generators are create0d in this paper, core to the security proof, if not is there a provable security benefit in these generators instead being issuer specific (e.g derived from the issuers public key) otherwise the simplest possible implementation would be for them to be global public parameters.",
          "createdAt": "2022-01-11T21:54:20Z",
          "updatedAt": "2022-01-11T21:54:20Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> In general though I still think the generators need to be context specific or domain separated\r\n\r\n@mikelodder7 is there a security basis you can point to for needing this? Anyway we could clarify with the authors of the Camenisch-Drijvers-Lehmann's paper whether the generators being generated randomly contributes to the security?",
          "createdAt": "2022-01-11T21:57:23Z",
          "updatedAt": "2022-01-11T21:57:23Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Suppose we have universal generators h_i, if I commit to a value using that it will be the same for all signatures. Think same encryption same key same message problem. \r\n\r\nThe bbs+ proof is also randomized even without a nonce (through r1, r2 etc.). Furthermore, the proof that it is zero knowledge does not make assumptions about the generators. The fact that it is zero-knowledge I think can ease those concerns. (not to say that it is not important for the generators to be sufficiently randomized)\r\n\r\nIn literature, it is true that Camenisch, Drijvers and Lehmann have hi as random elements and part of the Issuer\u2019s key but Man Ho Au, Susilo and Yi Mu refer to them as \u201cpublic common parameters\u201d and calculate them in a issuer independent way. In the end, if the generators are sufficiently randomized through a secure hash-function I don't see why any of the proofs will not be holding. But I also agree that care must be taken and contacting the authors seems a greet idea.",
          "createdAt": "2022-01-11T22:12:27Z",
          "updatedAt": "2022-01-11T22:12:27Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> In the end, if the generators are sufficiently randomized through a secure hash-function I don't see why any of the proofs will not be holding\r\n\r\n@BasileiosKal can you clarify, do you mean so long as the message generators were generated in a sufficiently random manner then they are safe to be re-used across multiple signatures even from different issuers? Or that they must be universally random?",
          "createdAt": "2022-01-11T22:15:37Z",
          "updatedAt": "2022-01-11T22:15:37Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @BasileiosKal can you clarify, do you mean so long as the message generators were generated in a sufficiently random manner then they are safe to be re-used across multiple signatures even from different issuers? Or that they must be universally random?\r\n\r\nYes my argument is that I think it is safe to reuse generators, as long as they where originally created to be sufficiently random.",
          "createdAt": "2022-01-11T22:36:57Z",
          "updatedAt": "2022-01-11T22:36:57Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "I\u2019m not as worried about the proofs as I am the signing. The other proposal from this group is to make signing deterministic which might also impact this.",
          "createdAt": "2022-01-11T22:42:16Z",
          "updatedAt": "2022-01-11T22:42:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I\u2019m not as worried about the proofs as I am the signing\r\n\r\nIs there a more specific security concern you could elaborate on here?\r\n\r\n> The other proposal from this group is to make signing deterministic which might also impact this.\r\n\r\nAnyway we can improve the understanding of the implications of this? For example does the current proposal for deterministic signatures for BBS mean that using global message generators across signatures is not possible?",
          "createdAt": "2022-01-11T22:53:46Z",
          "updatedAt": "2022-01-11T22:53:46Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 any follow up here about a specific security concern?",
          "createdAt": "2022-01-18T01:56:16Z",
          "updatedAt": "2022-01-18T01:56:16Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "> > I\u2019m not as worried about the proofs as I am the signing\r\n> \r\n> Is there a more specific security concern you could elaborate on here?\r\n\r\n\r\nusing the same generators with signatures could potentially leak the messages signed since the commitments will always be the same. Researching to see if this is as bad as I think it might be or not\r\n\r\n> \r\n> > The other proposal from this group is to make signing deterministic which might also impact this.\r\n> \r\n> Anyway we can improve the understanding of the implications of this? For example does the current proposal for deterministic signatures for BBS mean that using global message generators across signatures is not possible?\r\n\r\nNo we should be able to but it does mean signatures are distinct and unique which cryptographically isn\u2019t a problem but could be correlation risk.",
          "createdAt": "2022-01-18T18:09:28Z",
          "updatedAt": "2022-01-18T18:09:28Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> using the same generators with signatures could potentially leak the messages signed since the commitments will always be the same.\r\n\r\nI'm a bit confused, was it suggested to make the commitments deterministic as well?",
          "createdAt": "2022-01-18T18:33:30Z",
          "updatedAt": "2022-01-18T18:33:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It\u2019s true that random and fixed generators are not always equivalent (as shown by this https://eprint.iacr.org/2019/202.pdf paper). However, a takeaway from the paper is that that CDH is just as strong (or even stronger) in cases where a fixed, instead of a random generator, is used. The same result is proven for DL. Wouldn\u2019t that mean that if the sk is sufficiently randomized, the signature will be Indistinguishable from any other element in the group??\r\n\r\nAnother detail is that if we decide to use fixed generators, we should specify that the secret key should not have any dependency to that generator, to avoid problems like in the case of the strong power DDH mentioned in the same paper.\r\n\r\n> No we should be able to but it does mean signatures are distinct and unique which cryptographically isn\u2019t a problem but could be correlation risk.\r\n\r\nWouldn't that be the case even if the generators are not fixed?? If e and s are random, the signatures will be unique. IMO we should add a section to the Security Considerations, saying that the signature should be kept secret to avoid correlation.",
          "createdAt": "2022-01-20T13:53:30Z",
          "updatedAt": "2022-01-20T13:53:30Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After thinking more about this there may be a potential problem. Pairings make DDH in G1 easy, both in the fixed and in the random generator setting. Furthermore, I think there is a way, using exactly this fact, for an adversary to decide if 2 signatures are on the same messages `mod q`, if a fixed generator is used. \r\n\r\nIf `((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), e1, s1)` and `((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), e2, s2)` are two different signatures on `msg1` and `msg2` respectively (same generators and key, different `e` and `s` values) then the adversary could compute\r\n\r\n```\r\nI1 = e((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), w+P2*e1) * e(-P1 - h0*s1, P2) = \r\n    = e(P1 + h0*s1 + h[1]*msg1, P2) * e(-P1 - h0*s1, P2) => I1 = e(h[1]*msg1. P2)\r\n\r\nI2 = e((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), w+P2*e2) * e(-P1 - h0*s2, P2) = \r\n    = e(P1 + h0*s2 + h[1]*msg2, P2) * e(-g0 - h0*s2, P2) => I2 = e(h[1]*msg2. P2)\r\n```\r\n\r\nAs a result, if I'm not mistaken, the adversary could check if `I1 = I2` to decide if `msg1 = msg2 mod q`, which can correlate the two signatures. Note that the above method only works if there is only 1 message been signed by each signature.\r\n\r\nHowever, we can also prove that an adversary can not extract the message from the signature since such an adversary could be used to solve DL in G1; If the adversary `A` on input a bbs+ signature on the message `m` returns that message, we could just query `A` with `((g0 + h0*s + a)*(1/(e+x)), e, s)` where `a = h[1]*c` is the DL problem we trying to solve. Notice that the query is a valid bbs+ signature on `c` meaning that we will get from `A` the DL of `a` on the basis of `h[1]`, i.e., `c`.\r\n\r\nFor that reason, and the fact that even if we used random generators, there is no proof (currently) that two signatures on the same message couldn't be correlated (for example, if the same method as in the security proof of Lemma 1, in [this](https://eprint.iacr.org/2016/663.pdf) paper, is used to create random generators, the same method as above could be used to decide if `msg1 = msg2 mod q`), IMO the added complexity of using different random generators for each signature is not worth it. In most applications, the signatures will be kept private to avoid correlation either way, while if someone wants to actually use the signature, they will also disclose the signed messages.",
          "createdAt": "2022-01-23T20:28:22Z",
          "updatedAt": "2022-01-24T08:35:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@mikelodder7 ^",
          "createdAt": "2022-01-23T21:46:12Z",
          "updatedAt": "2022-01-23T21:46:12Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal if I understand your analysis correctly, if we do migrate to a construction of a BBS+ signature that is deterministic in nature on purpose due to the benefits it brings, then the ability for a possessor of two BBS signatures issued by the same issuer to know that the same set of messages were signed would become apparent anyway?\r\n\r\nIn general I agree with the thinking that correlation via the signature value is not a concern, this is present with most digital signature schemes anyway (esp those that are deterministic in nature like EdDSA or the deterministic construction for ECDSA). The added anti-correlation mechanisms of BBS+ come via the derived proofs, we should add a section in the privacy considerations that describes this nuance",
          "createdAt": "2022-01-23T22:04:42Z",
          "updatedAt": "2022-01-23T22:04:42Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> if we do migrate to a construction of a BBS+ signature that is deterministic in nature on purpose due to the benefits it brings, then the ability for a possessor of two BBS signatures issued by the same issuer to know that the same set of messages were signed would become apparent anyway?\r\n\r\nYes exactly. IMO this will not have any practical significance, especially since the message itself and the SK will be secure against an attacker. An addition to the security considerations section should suffice.",
          "createdAt": "2022-01-23T23:07:01Z",
          "updatedAt": "2022-01-23T23:07:01Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "Overall, I believe this is a good direction. But, I'd like to do formal security proof that default generators in a universal setup are secure. Also, the generator procedure should be able to be done via computation like domain -> shake256 -> hash2curve(index, okm, dst) -> G",
          "createdAt": "2022-01-24T17:16:55Z",
          "updatedAt": "2022-01-24T17:16:55Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If `((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), e1, s1)` and `((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), e2, s2)` are two different signatures on `msg1` and `msg2` respectively (same generators and key, different `e` and `s` values) then the adversary could compute\r\n> \r\n> ```\r\n> I1 = e((P1 + h0*s1 + h[1]*msg1)*(1/(e1+SK)), w+P2*e1) * e(-P1 - h0*s1, P2) = \r\n>     = e(P1 + h0*s1 + h[1]*msg1, P2) * e(-P1 - h0*s1, P2) => I1 = e(h[1]*msg1. P2)\r\n> \r\n> I2 = e((P1 + h0*s2 + h[1]*msg2)*(1/(e2+SK)), w+P2*e2) * e(-P1 - h0*s2, P2) = \r\n>     = e(P1 + h0*s2 + h[1]*msg2, P2) * e(-g0 - h0*s2, P2) => I2 = e(h[1]*msg2. P2)\r\n> ```\r\n> \r\n> As a result, if I'm not mistaken, the adversary could check if `I1 = I2` to decide if `msg1 = msg2 mod q`, which can correlate the two signatures. Note that the above method only works if there is only 1 message been signed by each signature.\r\n\r\nAs noted, this wouldn't really matter for signatures from a single issuer if deterministic signatures are adopted, however... when the same generators are shared, then it also works for signatures across multiple issuers, regardless of having deterministic signatures.\r\n\r\nThat said, I've been generally assuming that when the signature value itself is revealed (instead of using a ZKP), then all the messages are also expected to be revealed. That would be worth documenting if it is the case.",
          "createdAt": "2022-01-24T17:51:43Z",
          "updatedAt": "2022-01-24T17:52:33Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> But, I'd like to do formal security proof that default generators in a universal setup are secure\r\n\r\n+1. What security properties do we need to prove in the universal default generators setup?? Both the SK and -if my computations where not wrong- the message, are provably secure. On the other hand, the signatures could be correlated. What other security properties should we turn our attention to?",
          "createdAt": "2022-01-24T18:16:02Z",
          "updatedAt": "2022-01-24T18:16:02Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As noted, this wouldn't really matter for signatures from a single issuer if deterministic signatures are adopted, however... when the same generators are shared, then it also works for signatures across multiple issuers, regardless of having deterministic signatures.\r\n\r\nThat\u2019s a very interesting point. Maybe we should define P2 as issuer specific to avoid this problem (cross-issuer correlation of signatures on the same message)?? Although I do agree that it still does not seem to have enough practical significance to validate the added complexity. Adding to the documentation seems necessary though.",
          "createdAt": "2022-01-24T18:30:18Z",
          "updatedAt": "2022-01-24T18:30:18Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "> +1. What security properties do we need to prove in the universal default generators setup?? Both the SK and -if my computations where not wrong- the message, are provably secure. On the other hand, the signatures could be correlated. What other security properties should we turn our attention to?\r\n\r\nFirst, it should be secure in the scenario where multiple issuers are reusing the generators and it shouldn't be possible to know if the same message is signed at the same position. Second, an attacker should not be able to trick a signer by copying the commitments to another signer. I'll try to think of more properties as we go along. The second solution is already partially accounted for by using a blind signature proof of knowledge of committed values. I'm worried about the first scenario for both signing and proving.\r\n",
          "createdAt": "2022-01-24T18:57:11Z",
          "updatedAt": "2022-01-24T18:57:11Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "I_kwDOF8lax85ATp39",
      "title": "NIZK's must use fiat-shamir hash comparison",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/20",
      "state": "OPEN",
      "author": "mikelodder7",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When verifying any NIZK, it is necessary to check if the fiat-shamir heuristics are the same i.e. the challenges.\r\nComparing whether the commitments are the same is not enough. ",
      "createdAt": "2021-12-13T19:22:25Z",
      "updatedAt": "2021-12-13T19:22:25Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOF8lax85BdmyZ",
      "title": "Terminology clarification",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/24",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Clarify terminology for \r\n\r\nDomain Parameters\r\nGenerators (and their relationship to domain parameters)\r\nGenerators with specific purposes (e.g message generators and blinding factor generators)",
      "createdAt": "2022-01-10T19:20:10Z",
      "updatedAt": "2022-01-10T19:20:10Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOF8lax85BeKXa",
      "title": "Variable and function naming",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/25",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft uses the caret and tilde characters in variable naming, as they are in some of the source research. This causes issues with the markdown format of the specification in that it is burdensome and/or impossible to properly escape these characters.\r\n\r\nI don't see any clear standards on variable or function naming in other IETF drafts. Variables may be upper-, lower-, camel-, or snake-cased. Functions can be camel-cased, snake-cased, or kebab-case (ie. `HKDF-Extract`).\r\n\r\nSome suggestions for discussion:\r\n\r\n- name spec-internal variables and functions in snake case unless they represent an initialism (like `DST`) or are commonly capitalized (such as a field `F` or the set of integers `Z`). I think there is a tendency to use capitalized variables for elliptic curve points like `A` in the signature\r\n- name external functions according to their respective standards when possible, for example `hash_to_curve`\r\n- a trailing apostrophe is allowed in variable names, such as `s'` - precedent in hash-to-curve draft for example\r\n- for variables currently using `~` as a suffix use `_b` short for blinding factor\r\n- for variables currently using `^` as a suffix use `_c` short for commitment",
      "createdAt": "2022-01-10T21:53:34Z",
      "updatedAt": "2022-01-24T19:11:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bumblefudge",
          "authorAssociation": "NONE",
          "body": "See #17 ",
          "createdAt": "2022-01-24T19:11:41Z",
          "updatedAt": "2022-01-24T19:11:41Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "I_kwDOF8lax85CRz0I",
      "title": "Conceptually seperate message generators from public key definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/26",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At the moment in the draft a BBS signature public key is defined as an ordinary public key (using the based generator for the curve group) + a set of message generators used for committing messages to a BBS signature. Given the conversation occurring in #19 even if the outcome is to stick with a set of message generators that are derived through a deterministic process from the ordinary public key, I think we should remove the concept of a BBS signature public key and regard message generators as \"public parameters\" instead.",
      "createdAt": "2022-01-23T19:34:47Z",
      "updatedAt": "2022-01-23T19:34:47Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 27,
      "id": "I_kwDOF8lax85CR1vI",
      "title": "Setup automated tooling for publishing the latest version of the draft",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/27",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The authors of the [jwp draft](https://github.com/json-web-proofs/json-web-proofs) have done some great work in setting up automation around draft publishing / archiving and diff rendering, we should considering adopting similar technology to facilitate development of the draft.",
      "createdAt": "2022-01-23T20:10:05Z",
      "updatedAt": "2022-01-26T01:00:44Z",
      "closedAt": "2022-01-26T01:00:44Z",
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed with #32 ",
          "createdAt": "2022-01-26T01:00:44Z",
          "updatedAt": "2022-01-26T01:00:44Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "I_kwDOF8lax85CSaB6",
      "title": "Supporting bound BBS signature usecases",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/28",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As has been discussed before in [related communities](https://github.com/w3c-ccg/ldp-bbs2020/issues/37), the loose intended definition of bound BBS signatures refers to a signature that features a binding to a secret key (private key) possessed by the holder, which is required to be known by the holder in order to derive a proof using the signature. Effectively it is the introduction of a proof of key possession factor to a BBS signature which increases the assurances a relying party or verifier has when presented with a derived proof.\r\n\r\nMechanically this \"feature\" could be realised in multiple ways which affect the scope of this draft:\r\n1. Would be to leverage the blind sign functionality and treat the bound secret key as a blinded message.\r\n2. Would be to doing something more opinionated at the level of this draft introducing the concept of bound signatures and potentially removing the more flexible blind sign functionality.",
      "createdAt": "2022-01-24T03:23:22Z",
      "updatedAt": "2022-01-25T22:06:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "IMO if the main use case for blind signatures is for holder binding it may be better to move the blind signature functionality on a extension of the spec to keep the core spec as simple as possible (which IMO will be appreciated by the IETF). Holder binding could be achieved with similar but much simpler mechanisms.",
          "createdAt": "2022-01-24T18:47:21Z",
          "updatedAt": "2022-01-24T18:47:21Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would definitely be open to making the blind signature support an optional extension. For me it also raises questions about supporting deterministic signatures.",
          "createdAt": "2022-01-24T21:28:11Z",
          "updatedAt": "2022-01-24T21:28:11Z"
        },
        {
          "author": "brentzundel",
          "authorAssociation": "MEMBER",
          "body": "Since the underlying algorithm already natively supports the signing of blinded attributes which may be used for binding the signed data to a holder, it doesn't make sense to me to pursue alternative mechanisms for doing so.",
          "createdAt": "2022-01-25T16:52:58Z",
          "updatedAt": "2022-01-25T16:52:58Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Without a proposal for holder binding done in a more opinionated way, I can see this perspective, however I do think there are simpler options so will put together something more concrete to help inform this discussion.",
          "createdAt": "2022-01-25T20:05:44Z",
          "updatedAt": "2022-01-25T20:05:44Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> potentially removing the more flexible blind sign functionality.\r\n\r\nThis would invalidate private linking use-cases, where the holder wants to link different credentials together from multiple issuers without revealing the linkage to them, and can selectively disclose any linkages during presentation as needed.  This looks like binding but is subtly different as both may need to exist separately in such use-cases.\r\n\r\nAlso, blind signing is useful as a private witness where the issuer can sign something the holder wants witnessed without having to reveal the contents.\r\n\r\n",
          "createdAt": "2022-01-25T20:41:16Z",
          "updatedAt": "2022-01-25T20:41:16Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> This would invalidate private linking use-cases, where the holder wants to link different credentials together from multiple issuers without revealing the linkage to them, and can selectively disclose any linkages during presentation as needed. This looks like binding but is subtly different as both may need to exist separately in such use-cases.\r\n\r\n@quartzjer do you mean general private linking use-cases? like any attribute in common across credential / signatures? As i dont think this invalidates those usecases?\r\n\r\n> Also, blind signing is useful as a private witness where the issuer can sign something the holder wants witnessed without having to reveal the contents.\r\n\r\nAgree with this, but IMO this is really just stating the most general class of usecases that blind sign solves for, is there anything more concrete we could discuss?\r\n\r\nTo be clear im not saying arbitrary blind sign functionality is not useful, just questioning whether we need to standardize that now, vs via an extension later. Because it significantly complicates the current draft. Essentially all the blind sign functionality defines is a pre-protocol for how a holder constructs a commitment representing a set of blinded messages and an issuer verifies this before including it in their issued signature.",
          "createdAt": "2022-01-25T21:20:33Z",
          "updatedAt": "2022-01-25T21:20:33Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think it's also fair to say that even if blind signing is removed from the core spec, we would ensure that it was not made impossible, and the functionality would likely remain in existing implementations.",
          "createdAt": "2022-01-25T21:23:00Z",
          "updatedAt": "2022-01-25T21:23:00Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "+1 @andrewwhitehead exactly",
          "createdAt": "2022-01-25T21:29:31Z",
          "updatedAt": "2022-01-25T21:29:31Z"
        },
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "> do you mean general private linking use-cases?\r\n\r\nI was speaking to linking of multiple different credentials (by using the same link secret, blinded to multiple issuers).\r\n\r\n> I think it's also fair to say that even if blind signing is removed from the core spec, we would ensure that it was not made impossible, and the functionality would likely remain in existing implementations.\r\n\r\nAhh yes, this I completely understand and agree with, it can definitely be an extension since it is pretty self-isolated. ",
          "createdAt": "2022-01-25T22:00:59Z",
          "updatedAt": "2022-01-25T22:00:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "> I was speaking to linking of multiple different credentials (by using the same link secret, blinded to multiple issuers).\r\n\r\nOk great the proposal made in this issue would not eliminate that capability. As said above we are really just talking about the pre-protocol around blinding messages for an issuer to sign.",
          "createdAt": "2022-01-25T22:06:32Z",
          "updatedAt": "2022-01-25T22:06:32Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "I_kwDOF8lax85CSaUd",
      "title": "Supporting use cases for blind signing",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/29",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the spec documents a procedure for constructing BBS signatures where by some / all of the messages signed by the signer are unknown to them. This issue is to discuss the usecases for this feature and whether it should remain in scope for the core spec of whether it could be added in the form of a seperate extension specification. The tradeoff being that electing to keep blind signing in scope significantly increases deliverables for the spec in the form of multiple cryptographic operations and data structures.\r\n\r\nNote - related to this is a discussion on how we should handle \"bound\" bbs signatures captured in issue #28",
      "createdAt": "2022-01-24T03:25:08Z",
      "updatedAt": "2022-01-24T03:25:08Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOF8lax85CbKCy",
      "title": "Naming of the draft BBS vs BBS+",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/30",
      "state": "CLOSED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I propose we rename the draft to \"The BBS Signature Scheme\" and elect to drop the + from all mentions of BBS. Through appropriate citations of the academic work I think we can still achieve the right level of association to the schemes origins. The rationale for dropping the + is that in many visible places that character is not allowed (e.g naming repositories, naming packages and programming language syntax)",
      "createdAt": "2022-01-25T22:14:16Z",
      "updatedAt": "2022-01-26T00:52:59Z",
      "closedAt": "2022-01-26T00:52:58Z",
      "comments": [
        {
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "body": "I definitely support this :+1:.",
          "createdAt": "2022-01-25T22:23:33Z",
          "updatedAt": "2022-01-25T22:23:33Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addressed in #32 there was only two minor inconsistencies in the draft already that have been addressed",
          "createdAt": "2022-01-26T00:52:58Z",
          "updatedAt": "2022-01-26T00:52:58Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "I_kwDOF8lax85CbLrn",
      "title": "Remove KeyGen definition",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/31",
      "state": "OPEN",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This may be defined as a property of the profile along with details of the pairing-friendly curve in use. For BLS curves it probably makes sense to reference the BLS Signatures IETF draft (hopefully that is getting an update?).",
      "createdAt": "2022-01-25T22:23:33Z",
      "updatedAt": "2022-01-26T09:16:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "For reference the draft is located here https://github.com/cfrg/draft-irtf-cfrg-bls-signature",
          "createdAt": "2022-01-26T09:12:35Z",
          "updatedAt": "2022-01-26T09:15:14Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "In particular this section https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature-04#section-2.3",
          "createdAt": "2022-01-26T09:16:06Z",
          "updatedAt": "2022-01-26T09:16:06Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOF8lax85CbhY5",
      "title": "Consider renaming nonce in the proof to presentation message",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/33",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the WG call on the 24th of Jan, the usage of the term nonce was found to confuse reviewers of #21, upon discussing this the suggestion was to potentially rename this to presentation message as was the case with uProve.",
      "createdAt": "2022-01-26T00:54:36Z",
      "updatedAt": "2022-01-26T00:54:36Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 34,
      "id": "I_kwDOF8lax85CbiGG",
      "title": "Add documentation on how contributors can build the HTML / TXT version of spec locally",
      "url": "https://github.com/decentralized-identity/bbs-signature/issues/34",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Requires users to have make installed, list commands and add to a contributors document in the repository",
      "createdAt": "2022-01-26T01:00:19Z",
      "updatedAt": "2022-01-26T01:00:19Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 9,
      "id": "PR_kwDOF8lax84s53qY",
      "title": "Add meeting details to README",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/9",
      "state": "MERGED",
      "author": "andrewwhitehead",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-07T16:52:48Z",
      "updatedAt": "2021-10-07T18:46:46Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8ef9959beab15364dd28e1816d8daa040164608d",
      "headRepository": "andrewwhitehead/bbs-signature",
      "headRefName": "add-meetings",
      "headRefOid": "83ca77c2b6f7cb9155e0b01cb689d41abf3c4642",
      "closedAt": "2021-10-07T18:46:46Z",
      "mergedAt": "2021-10-07T18:46:46Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "580bd262102859b1a06fb82c7089b60771e1a0de"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84uJnZd",
          "commit": {
            "abbreviatedOid": "83ca77c"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T18:46:40Z",
          "updatedAt": "2021-10-07T18:46:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "PR_kwDOF8lax84t5asa",
      "title": "Remove mention of specific of hash function",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/12",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "An attempt to start discussion around #8 in regards to the digest algorithm. \r\n\r\nAt a minimum I am interpreting from that issue we agree that our usage of a digest algorithm should be specified once and referenced throughout the draft. The outstanding issue is whether the draft should just provide guidance around recommended digest algorithms or adopt an approach more akin to EdDSA where a particular digest algorithm forms a core part of the signature specification (e.g implementers MUST use BLAKE2B or SHAKE256)",
      "createdAt": "2021-10-31T22:13:52Z",
      "updatedAt": "2021-11-15T18:28:25Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "580bd262102859b1a06fb82c7089b60771e1a0de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/hash-function",
      "headRefOid": "7a6d70429d5eb7b9b718de909052ddbea4f6d6fc",
      "closedAt": "2021-11-15T18:28:01Z",
      "mergedAt": "2021-11-15T18:28:01Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9fc1ef136c2d437d59d11688a3fbaa1632421c75"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84vW2EV",
          "commit": {
            "abbreviatedOid": "7a6d704"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-01T18:26:04Z",
          "updatedAt": "2021-11-01T18:26:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 13,
      "id": "PR_kwDOF8lax84t5bNx",
      "title": "move ecc signature comparission to appendix",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/13",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The comparing of bbs signatures to more traditional digital signature schemes like ECDSA is interesting informative content, but it is perhaps better discussed in the appendix rather than forming a core section in the draft, this PR proposes we move it accordingly.",
      "createdAt": "2021-10-31T22:27:06Z",
      "updatedAt": "2021-11-15T18:27:52Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "580bd262102859b1a06fb82c7089b60771e1a0de",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/remove-ecc-signatures-comparison",
      "headRefOid": "0bb0d372ed1cfabd9112eb8dd51d63a5f1e8ee43",
      "closedAt": "2021-11-15T18:27:45Z",
      "mergedAt": "2021-11-15T18:27:45Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "9a9602526a0642ce4816ad472cb50d200eb1c76c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84vW1hZ",
          "commit": {
            "abbreviatedOid": "0bb0d37"
          },
          "author": "quartzjer",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-01T18:23:39Z",
          "updatedAt": "2021-11-01T18:23:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOF8lax84u4XLB",
      "title": "Changes in the handling of reveled message indexes",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/14",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes in spkGen and spkVerify, in the direction discussed in the last WG call, of a more agile spec (aligned with option 1 from @tplooker's comment [here](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-939546272)). Specifically,\r\n\r\n1. Added a revealed message indexes vector in the input to spkVerify\r\n2. Added a recommendation for proof value encoding, similar to the one from ECDSA [RFC6979](https://datatracker.ietf.org/doc/html/rfc6979), with an additional preceding structure (taken from #10 , aligned with option 3 from the same [comment](https://github.com/decentralized-identity/bbs-signature/issues/10#issuecomment-939546272) as above).\r\n3. Changed some of the indexing in spkGen and spkVerify to accommodate the changes above",
      "createdAt": "2021-11-23T00:20:55Z",
      "updatedAt": "2021-12-13T19:14:29Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "91149814047a7c1fe11139bc787c2ea194efc5e0",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "revealed_msg_indices",
      "headRefOid": "f05fbb24d7e7d4de05c11b6989eab19b00ba8a36",
      "closedAt": "2021-12-13T19:14:29Z",
      "mergedAt": "2021-12-13T19:14:28Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0914df5a07eb0cf3eff6b4629ec2e34fcd9cc48b"
      },
      "comments": [
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done applying changes!",
          "createdAt": "2021-11-24T23:29:36Z",
          "updatedAt": "2021-11-24T23:29:36Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Waiting for discussion at next working group meeting to merge",
          "createdAt": "2021-11-28T19:30:11Z",
          "updatedAt": "2021-11-28T19:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84wmZY6",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:01:54Z",
          "updatedAt": "2021-11-24T21:01:54Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n- RIdxs, vector of unsigned integers (indices of revealed messages).\r\n```",
              "createdAt": "2021-11-24T21:01:54Z",
              "updatedAt": "2021-11-24T21:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZqm",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:03:44Z",
          "updatedAt": "2021-11-24T21:03:44Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\nHow a signature is to be encoded is not covered by this document. (TODO perhaps add some additional information in the appendix)\r\n```",
              "createdAt": "2021-11-24T21:03:44Z",
              "updatedAt": "2021-11-24T21:03:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZu4",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-24T21:04:11Z",
          "updatedAt": "2021-11-24T21:04:12Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "```suggestion\r\n- RIdxs, vector of unsigned integers (indices of revealed messages).\r\n```",
              "createdAt": "2021-11-24T21:04:11Z",
              "updatedAt": "2021-11-24T21:04:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84wmZ1a",
          "commit": {
            "abbreviatedOid": "8be003d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Looking good, suggested a few changes",
          "createdAt": "2021-11-24T21:04:45Z",
          "updatedAt": "2021-11-24T21:04:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84wpz6n",
          "commit": {
            "abbreviatedOid": "c2909a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-25T19:40:29Z",
          "updatedAt": "2021-11-25T19:40:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84xgrN6",
          "commit": {
            "abbreviatedOid": "c2909a9"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T19:13:37Z",
          "updatedAt": "2021-12-13T19:13:37Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "```suggestion\r\n13. Y2 = d \\* r3^ + h0 \\* s^ + h\\[i1\\] \\* m^\\[i1\\] + ... + h\\[iR\\] \\* m^\\[iR\\] - T2 \\* c\r\n```",
              "createdAt": "2021-12-13T19:13:37Z",
              "updatedAt": "2021-12-13T19:13:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 17,
      "id": "PR_kwDOF8lax84vuKnC",
      "title": "Checks for the blind message generators and PoK during signing",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/17",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Related to #16.\r\n\r\n1. Added an explicit use of BlindMessageProofVerify in BlindSign to validate the PoK of committed messages, and a check that the generators used in the commitment are not also used for the known messages.\r\n2. Changed some of the notation to accommodate those changes above. The new notation can be also used more easily if we want to add support for blind signing with multiple commitments.",
      "createdAt": "2021-12-12T10:59:24Z",
      "updatedAt": "2022-01-24T19:12:06Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "commitment_generators_validation",
      "headRefOid": "243d31012ce2b436be31b0be4f54db1f64b18557",
      "closedAt": "2022-01-24T19:12:06Z",
      "mergedAt": "2022-01-24T19:12:05Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bab36cced182c0a1122b543fb50cefb7078184f0"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call on 15th of dec @BasileiosKal has an action to make some changes requested by @andrewwhitehead and @mikelodder7 ",
          "createdAt": "2021-12-13T19:23:54Z",
          "updatedAt": "2021-12-13T19:23:54Z"
        },
        {
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree and I updated this pr.  However, it does seem that a wider update to the spec may be needed.  It may also be useful to specify the domain parameters used by each function, similarly to the format from [here](https://www.ietf.org/archive/id/draft-irtf-cfrg-rsa-blind-signatures-02.html).<br/>\r\nIt also seems like [this ](https://github.com/decentralized-identity/bbs-signature/issues/19) issue (#19 ) will be relevant i.e., if we don't change the way the generators are created, it may be confusing to refer to them as domain parameters and have them be both issuer and number of messages specific. ",
          "createdAt": "2021-12-23T23:41:08Z",
          "updatedAt": "2021-12-23T23:43:11Z"
        },
        {
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "body": "Agreed. Perhaps we use the current spec as an example for creating the domain parameters. The point is they need to be distinct points whose discrete log is unknown ",
          "createdAt": "2021-12-23T23:44:43Z",
          "updatedAt": "2021-12-23T23:44:43Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Related to #19, @andrewwhitehead to supply a review to this PR",
          "createdAt": "2022-01-10T19:39:59Z",
          "updatedAt": "2022-01-10T19:39:59Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think my only objections are around the variable naming. I have an issue open around that, and we can do another pass renaming things later.",
          "createdAt": "2022-01-24T18:10:15Z",
          "updatedAt": "2022-01-24T18:10:15Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call 24th Jan, resolved to merge",
          "createdAt": "2022-01-24T19:12:00Z",
          "updatedAt": "2022-01-24T19:12:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84xdBbY",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T00:18:43Z",
          "updatedAt": "2021-12-13T00:18:44Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "When we say \"octet string\" here are we meaning a string with some form of defined encoding like hexadecimal or instead are we assuming any parameters that are binary in nature be supplied as byte array?",
              "createdAt": "2021-12-13T00:18:44Z",
              "updatedAt": "2021-12-13T00:18:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84xdBfH",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T00:20:14Z",
          "updatedAt": "2021-12-13T00:20:14Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Probably should define `ceil` in terminology also even though it probably obvious to most",
              "createdAt": "2021-12-13T00:20:14Z",
              "updatedAt": "2021-12-13T00:20:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84xdFUq",
          "commit": {
            "abbreviatedOid": "a13753d"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T01:34:54Z",
          "updatedAt": "2021-12-13T01:34:54Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "My understanding is that currently by octet string we mean just a byte array with no specific encoding, mainly used to represent points in extension fields using the format described [here ](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10) in [subsection 2.5](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-10#section-2.5), or for representing nonnegative integers using the conversions described [here](https://www.rfc-editor.org/rfc/rfc8017.txt) at section 4.",
              "createdAt": "2021-12-13T01:34:54Z",
              "updatedAt": "2021-12-13T01:34:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yCdmc",
          "commit": {
            "abbreviatedOid": "5120485"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "The part about the key being 48 * (messages +1) isn\u2019t always accurate. I would like to rename these generators to domain parameters as this is the more common with cryptography. That means the public key has a fixed size of 96 bytes. \r\n\r\nThe reason for the distinction is the domain parameters have no secret meaning vs a public key indicates a secret key behind it",
          "createdAt": "2021-12-23T17:00:40Z",
          "updatedAt": "2021-12-23T17:00:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zWAYB",
          "commit": {
            "abbreviatedOid": "243d310"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-24T19:11:27Z",
          "updatedAt": "2022-01-24T19:11:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 18,
      "id": "PR_kwDOF8lax84vuhiv",
      "title": "Blind Sign Flow Example",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/18",
      "state": "MERGED",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An example for the flow by which the Holder gets a signature with committed messages. The holder commits U messages using the first U generators from the Issuers PK.",
      "createdAt": "2021-12-12T20:06:51Z",
      "updatedAt": "2021-12-21T20:31:40Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "0914df5a07eb0cf3eff6b4629ec2e34fcd9cc48b",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "blind_sign_example",
      "headRefOid": "3695dee5e2f4d6b0a3c8fe934ec404913c0c2a2c",
      "closedAt": "2021-12-21T20:31:40Z",
      "mergedAt": "2021-12-21T20:31:40Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Informational and in the appendix, no objections on last working group call, merging.",
          "createdAt": "2021-12-21T20:31:35Z",
          "updatedAt": "2021-12-21T20:31:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84xgt51",
          "commit": {
            "abbreviatedOid": "35d9d99"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T19:25:20Z",
          "updatedAt": "2021-12-13T19:25:21Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n|        | <-(1)------- nonce ---------- |        |\r\n```",
              "createdAt": "2021-12-13T19:25:20Z",
              "updatedAt": "2021-12-13T19:25:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOF8lax84wvGmp",
      "title": "Clarified nonce requirements",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/21",
      "state": "OPEN",
      "author": "christianpaquin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Clarified usage of nonce when use in a non-interactive protocol.",
      "createdAt": "2022-01-10T14:03:36Z",
      "updatedAt": "2022-01-26T00:51:50Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "christianpaquin/bbs-signature",
      "headRefName": "nonce-issue-15",
      "headRefOid": "d23c300a2260f9ba28060d00ee9efe7e7e1e574d",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Addresses issue #15 ",
          "createdAt": "2022-01-10T19:40:49Z",
          "updatedAt": "2022-01-10T19:40:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on Jan 10th WG call, resolved to merge after 1 day if no further objection or feedback.",
          "createdAt": "2022-01-10T19:45:51Z",
          "updatedAt": "2022-01-10T19:45:51Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure the text `BBS signatures are nondeterministic` is still true depending how the nonces are chosen. It also might be good to refer to `e` and `s` specifically in the context of nonce selection (at least I think those are the relevant nonces?). I'm not sure why a signed document would include a ZKP of a signature rather than the signature itself but maybe there's a use for that.",
          "createdAt": "2022-01-10T22:42:17Z",
          "updatedAt": "2022-01-10T22:42:17Z"
        },
        {
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm, I also can't imagine how blinded signatures would be used in a non-interactive or deterministic context.",
          "createdAt": "2022-01-10T23:14:04Z",
          "updatedAt": "2022-01-10T23:14:04Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": ">I'm not sure why a signed document would include a ZKP of a signature rather than the signature itself but maybe there's a use for that.\r\n\r\nThe use case I referred [here](https://github.com/decentralized-identity/bbs-signature/issues/15#issuecomment-978239178) if you want to sign a statement without identifying yourself, think role-based signature similar to role-based access. A BBS+ cred owner could sign a statement, disclosing some attributes attested by a trusted issuer.\r\n",
          "createdAt": "2022-01-11T14:37:52Z",
          "updatedAt": "2022-01-11T14:37:52Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "> I also can't imagine how blinded signatures would be used in a non-interactive or deterministic context.\r\n\r\nOne scenario that dates way back to Chaum's credential days was toll booths, where passing cars could present a payment by signing a booth ID + timestamp. Prover just broadcasts the proof to get access to a resource, using a (verifier ID + timestamp + small random value) as the nonce. Verifiers can prevent replays by keeping a local cache of used nonces (deleting as the timestamps get too old).",
          "createdAt": "2022-01-11T14:53:13Z",
          "updatedAt": "2022-01-11T14:53:13Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@andrewwhitehead any concrete proposal that could be suggested here to move this PR along?",
          "createdAt": "2022-01-24T03:26:57Z",
          "updatedAt": "2022-01-24T03:26:57Z"
        },
        {
          "author": "christianpaquin",
          "authorAssociation": "NONE",
          "body": "Comments from the Jan 24th meeting: yes, the nonce terminology contradicts the deterministic use cases. Perhaps renaming it to something more neutral would help generalize the supported scenarios. In U-Prove, e.g., the `nonce` was called `presentation message`, which could be a nonce (for interactive scenarios), a verifierID+timestamp for user-initiated non-interactive scenarios, or static content for digital signature use cases.",
          "createdAt": "2022-01-24T19:35:25Z",
          "updatedAt": "2022-01-24T19:35:25Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "> Comments from the Jan 24th meeting: yes, the nonce terminology contradicts the deterministic use cases. Perhaps renaming it to something more neutral would help generalize the supported scenarios. In U-Prove, e.g., the `nonce` was called `presentation message`, which could be a nonce (for interactive scenarios), a verifierID+timestamp for user-initiated non-interactive scenarios, or static content for digital signature use cases.\r\n\r\nI think that's a good description of an application of a nonce, when it's used in a deterministic scenario, but not general enough. `Challenge` may be used when interaction is needed in a non-deterministic manner. A `nonce` can then become a `presentation message`, a `challenge`, or even a `pin` to be more specific. This makes me think that `nonce` is indeed a good way that's general enough to refer to this input.",
          "createdAt": "2022-01-24T21:48:16Z",
          "updatedAt": "2022-01-24T21:48:59Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@christianpaquin apologies but we have renamed the spec file name so we leverage existing tooling around managing ID drafts, can you please rebase your PR accordingly?",
          "createdAt": "2022-01-26T00:51:50Z",
          "updatedAt": "2022-01-26T00:51:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84yj4t4",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-10T19:45:02Z",
          "updatedAt": "2022-01-10T19:45:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zWi6J",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T21:41:35Z",
          "updatedAt": "2022-01-24T21:41:36Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "While I share the idea that there are very good use cases where deterministic nonce can be used here, I think they make more sense in higher level protocols. Especially, since the wording used here may incorrectly guide implementors to adopt timestamp for a nonce.\r\nI think a shorter guidance describing that this parameter be unique, and random enough would be more appropriate.\r\n\r\nSpecific implementations may still make a conscious choice to use deterministic value where security or risk impact tolerates this. For example: attendees at a conference can prepare a proof by using the room number for a conference where both verifier and presenter know this nonce and require no interaction, thus simplifying the verification experience.",
              "createdAt": "2022-01-24T21:41:36Z",
              "updatedAt": "2022-01-24T21:41:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zWjfl",
          "commit": {
            "abbreviatedOid": "d23c300"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T21:44:15Z",
          "updatedAt": "2022-01-24T21:44:15Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't know what standard in cryptography is used to reference to good randomness. Maybe [this RFC](https://datatracker.ietf.org/doc/html/rfc4086) may be more appropriate to quote here?",
              "createdAt": "2022-01-24T21:44:15Z",
              "updatedAt": "2022-01-24T21:44:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOF8lax84wv9WU",
      "title": "Add various comments as FIXMEs",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/22",
      "state": "MERGED",
      "author": "schanzen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Related to #7 and #8\r\n\r\nDid a pass of the document and was wondering to what degree it is supposed to be normative. If it is **not** supposed to be, it should be made clear(er) what the diff over the respective papers (informative references to those missing) is.\r\nAlso, normative references (such as those to the HKDF) are not required then.\r\n\r\nIf it is supposed to be normative, it requires the definition of (at least) one concrete instantiation (with hash functions/curves) and normative test vectors and wire formats.\r\n\r\nOnce we can clarify those points I can replace the FIXMEs aligning with the target.",
      "createdAt": "2022-01-10T17:50:51Z",
      "updatedAt": "2022-01-25T22:56:11Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "schanzen/bbs-signature",
      "headRefName": "comments",
      "headRefOid": "70c145526d995440b5d876eeedbb537bf85e51da",
      "closedAt": "2022-01-25T22:56:11Z",
      "mergedAt": "2022-01-25T22:56:11Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "56d413acd3d43588c93964ba3f38d88a094a220d"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Purely editorial changes, multiple approvals, discussed on WG, merging, thanks @schanzen ",
          "createdAt": "2022-01-25T22:56:07Z",
          "updatedAt": "2022-01-25T22:56:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84ykm-4",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:23:57Z",
          "updatedAt": "2022-01-10T23:23:57Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "I think those 680 and 1400 numbers are also in microseconds not milliseconds?",
              "createdAt": "2022-01-10T23:23:57Z",
              "updatedAt": "2022-01-10T23:23:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykoYi",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:34:23Z",
          "updatedAt": "2022-01-10T23:34:24Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Why does it need justification?",
              "createdAt": "2022-01-10T23:34:24Z",
              "updatedAt": "2022-01-10T23:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykocK",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T23:34:49Z",
          "updatedAt": "2022-01-10T23:34:49Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Same here, not sure what the suggested change would be.",
              "createdAt": "2022-01-10T23:34:49Z",
              "updatedAt": "2022-01-10T23:34:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yl99T",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:23:31Z",
          "updatedAt": "2022-01-11T08:23:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Because above it it says \"The scheme features many important properties:\"\r\nIt is unclear why this generic property is important.\r\nI changed this sentence above in the pull request already.\r\nIf this is just a general note then it is not an important property of the scheme I think.",
              "createdAt": "2022-01-11T08:23:31Z",
              "updatedAt": "2022-01-11T08:23:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yl_T5",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:25:55Z",
          "updatedAt": "2022-01-11T08:25:55Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "It also kind of implies that there is space time tradeoff and that BBS can sign any number of messages in 680/1400ms. So maybe the 3.7 and 5.4 actually refer to ECDSA. Not sure.",
              "createdAt": "2022-01-11T08:25:55Z",
              "updatedAt": "2022-01-11T08:25:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ymA6S",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:31:11Z",
          "updatedAt": "2022-01-11T08:31:11Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Well let me rephrase it using the words from the (original) text:\r\nHow is \"Verification requires 2 pairing operations.\" a \"[property that] allow[s] the scheme to be used in applications where privacy and data minimization techniques are desired and/or required.\"?\r\nThat is what the text currently says, and it is unclear (to me) where the connection is.",
              "createdAt": "2022-01-11T08:31:11Z",
              "updatedAt": "2022-01-11T08:31:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ymBz2",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:34:53Z",
          "updatedAt": "2022-01-11T08:34:54Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Also, the \"encoding\" of the signature would usually refer to a normative (interoperable) wire format of the signature. Maybe what is meant here is that the signatures are \"represented\" as a single group element and two field elements?\r\nLater in the text it is also stated that \"How a signature is to be encoded is not covered by this document. (TODO perhaps add some additional information in the appendix)\"",
              "createdAt": "2022-01-11T08:34:53Z",
              "updatedAt": "2022-01-11T08:35:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6b3",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:16:04Z",
          "updatedAt": "2022-01-13T01:16:04Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "@mikelodder7 I think you originally wrote this could you clarify, IMO this section can likely be removed from the spec as it is entirely non-normative.",
              "createdAt": "2022-01-13T01:16:04Z",
              "updatedAt": "2022-01-13T01:16:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6jN",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:17:10Z",
          "updatedAt": "2022-01-13T01:17:11Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I think I agree with your comment here but could you clarify what you mean by \"wire format\" specifically and what you would take as the definition of encoding format?",
              "createdAt": "2022-01-13T01:17:10Z",
              "updatedAt": "2022-01-13T01:17:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yu6mI",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T01:17:35Z",
          "updatedAt": "2022-01-13T01:17:35Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "If it is a duplicate then I think we should just remove it",
              "createdAt": "2022-01-13T01:17:35Z",
              "updatedAt": "2022-01-13T01:17:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yvD8o",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T02:41:09Z",
          "updatedAt": "2022-01-13T02:41:09Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Sure feel free to remove it.",
              "createdAt": "2022-01-13T02:41:09Z",
              "updatedAt": "2022-01-13T02:41:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yvxZ_",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "schanzen",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-13T08:23:04Z",
          "updatedAt": "2022-01-13T08:23:05Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "As an implementer I would expect qualifiers such as \"32 octets\" or \"variable length\" (with a length field) for the members of the tuple and then a normative ordering of them (for example by having a wire format graphic or a concatenation of the octet strings).\r\nThe point is that when I eventually code my structs, I need to know the size of its members and their location.\r\nOtherwise I do not even know how to parse a test vector (if provided).\r\nThis unclarity may have to do with #8 which makes normative statements more difficult to incorporate.",
              "createdAt": "2022-01-13T08:23:04Z",
              "updatedAt": "2022-01-13T08:23:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84y9G62",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-18T01:55:26Z",
          "updatedAt": "2022-01-18T01:55:26Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "Yeah I think this is covered by issue #2 and we should aim to review it on the next working group call to provide better clarity around the direction the WG would like to take this",
              "createdAt": "2022-01-18T01:55:26Z",
              "updatedAt": "2022-01-18T01:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSWwH",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:29:11Z",
          "updatedAt": "2022-01-24T03:29:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "@schanzen, could you update your PR to just remove this section entirely from the appendix?",
              "createdAt": "2022-01-24T03:29:12Z",
              "updatedAt": "2022-01-24T03:29:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSW4N",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:30:46Z",
          "updatedAt": "2022-01-24T03:30:47Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Have reviewed, @schanzen can you remove the duplicate language around SK, then we can resolve this FIX me",
              "createdAt": "2022-01-24T03:30:46Z",
              "updatedAt": "2022-01-24T03:30:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSXAF",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:32:17Z",
          "updatedAt": "2022-01-24T03:32:17Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "+1 reading the context it does not appear apparent why this needs to be bulleted as it is, I would vote to remove it.",
              "createdAt": "2022-01-24T03:32:17Z",
              "updatedAt": "2022-01-24T03:32:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zSXDG",
          "commit": {
            "abbreviatedOid": "daf0b5e"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-24T03:32:51Z",
          "updatedAt": "2022-01-24T03:32:51Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "+1 as above I think this should be removed also",
              "createdAt": "2022-01-24T03:32:51Z",
              "updatedAt": "2022-01-24T03:32:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zb0yS",
          "commit": {
            "abbreviatedOid": "70c1455"
          },
          "author": "andrewwhitehead",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T22:23:57Z",
          "updatedAt": "2022-01-25T22:23:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOF8lax84zb7fj",
          "commit": {
            "abbreviatedOid": "70c1455"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-25T22:55:43Z",
          "updatedAt": "2022-01-25T22:55:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOF8lax84wwBeS",
      "title": "Check the hash for the challenge of the Fiat-Shamir heuristic",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/23",
      "state": "OPEN",
      "author": "BasileiosKal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Attempts to fix #20\r\n\r\nChanges: \r\n\r\n1. SpkGen returns the computed challenge for Fiat-Shamir.\r\n2. SpkVerify checks that the challenge is correct.",
      "createdAt": "2022-01-10T18:13:34Z",
      "updatedAt": "2022-01-26T00:58:17Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "8b0709f9e450fb1d37f8952d00dfa5ce4086f36e",
      "headRepository": "BasileiosKal/bbs-signature",
      "headRefName": "issue20-fix",
      "headRefOid": "b97272e11ede17af926ae12b2c8c894dfc635fe4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Discussed on WG call Jan 10th, waiting on a review from @mikelodder7 as the underlying issue was raised by him. ",
          "createdAt": "2022-01-10T19:53:34Z",
          "updatedAt": "2022-01-10T19:53:34Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@BasileiosKal apologies but we have renamed the spec file name so we leverage existing tooling around managing ID drafts, can you please rebase your PR accordingly?",
          "createdAt": "2022-01-26T00:58:17Z",
          "updatedAt": "2022-01-26T00:58:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84yj6_q",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:55:16Z",
          "updatedAt": "2022-01-10T19:55:18Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "These steps are not necessary since they should be handled by the challenge hash.",
              "createdAt": "2022-01-10T19:55:17Z",
              "updatedAt": "2022-01-10T19:55:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yj7DV",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:55:34Z",
          "updatedAt": "2022-01-10T19:55:35Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I.E 11-16 are not necessary",
              "createdAt": "2022-01-10T19:55:34Z",
              "updatedAt": "2022-01-10T19:55:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84yj7R3",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T19:56:38Z",
          "updatedAt": "2022-01-10T19:56:38Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "See https://hackmd.io/Q587Q9p7T5ab30NTn4MvTA#Change-selective-disclosure-proofs-to-just-be-Schnorr-Proofs-and-Fiat-Shamir",
              "createdAt": "2022-01-10T19:56:38Z",
              "updatedAt": "2022-01-10T19:56:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFGm",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "BasileiosKal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:42:52Z",
          "updatedAt": "2022-01-10T20:42:52Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Thank you for the link. It is very interesting. Perhaps I will have to think more about it but it seems to me that some of the steps are needed. If we change the hash calculated at step 9 here to contain Y1 and Y2 instead of C1 and C2 (and of course to be calculated in a later step), perhaps we could remove the checks at steps 15 and 16, and consequently remove C1 and C2 from the spk returned from SpkGen. However, steps 10 to 14 don't seem to me that we could remove them, they are an integral part of the Schnorr proof after all.",
              "createdAt": "2022-01-10T20:42:52Z",
              "updatedAt": "2022-01-10T20:42:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFrQ",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:45:25Z",
          "updatedAt": "2022-01-10T20:45:26Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "The problem is it\u2019s being calculated twice. Once for the hash and then again checked for equality which is why I said in my write up they can be removed",
              "createdAt": "2022-01-10T20:45:26Z",
              "updatedAt": "2022-01-10T20:45:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84ykFvs",
          "commit": {
            "abbreviatedOid": "b97272e"
          },
          "author": "mikelodder7",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:45:46Z",
          "updatedAt": "2022-01-10T20:45:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "If the values are different, the hash will be too. ",
              "createdAt": "2022-01-10T20:45:46Z",
              "updatedAt": "2022-01-10T20:45:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 32,
      "id": "PR_kwDOF8lax84xlpRj",
      "title": "Add ID tooling, remove redundant scripts",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/32",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "- Add basic tooling for managing this spec as an ID draft based on https://github.com/martinthomson/internet-draft-template.\r\n- Removes some redundant scripts for old tooling.\r\n- Removes old HTML version.\r\n- Minor tweaks to draft naming based on #30 \r\n",
      "createdAt": "2022-01-25T23:22:30Z",
      "updatedAt": "2022-01-26T00:22:23Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "56d413acd3d43588c93964ba3f38d88a094a220d",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/id-tooling-setup",
      "headRefOid": "72f9be671202019daa497969f02efa049266e901",
      "closedAt": "2022-01-26T00:22:20Z",
      "mergedAt": "2022-01-26T00:22:20Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "e77c5ce55cad7274c1c3d35850023205edc702b9"
      },
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "Merging PR so we can get spec hosting working correctly, no substantive changes to the spec text.",
          "createdAt": "2022-01-26T00:22:15Z",
          "updatedAt": "2022-01-26T00:22:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zcDqD",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:55:26Z",
          "updatedAt": "2022-01-25T23:55:26Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "remove comments?",
              "createdAt": "2022-01-25T23:55:26Z",
              "updatedAt": "2022-01-25T23:55:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcD-b",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:58:00Z",
          "updatedAt": "2022-01-25T23:58:00Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Looks like you are no longer using markdown2rfc.... I had to bump the version recently... https://github.com/OR13/markdown2rfc\r\n\r\nI wanted to render latex equations as svgs... ",
              "createdAt": "2022-01-25T23:58:00Z",
              "updatedAt": "2022-01-25T23:58:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcEDT",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "OR13",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-25T23:58:43Z",
          "updatedAt": "2022-01-25T23:58:44Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "I love the idea of github handling this all for you tho, i would still probably want to test it locally.... consider adding some instructions to the readme to help with that? and adding the built assets to git ignore?",
              "createdAt": "2022-01-25T23:58:43Z",
              "updatedAt": "2022-01-25T23:59:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcFie",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:10:32Z",
          "updatedAt": "2022-01-26T00:10:32Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "It just describes how the tool is run copied directly from the template (https://github.com/martinthomson/internet-draft-template/blob/main/.github/workflows/update.yml#L2)",
              "createdAt": "2022-01-26T00:10:32Z",
              "updatedAt": "2022-01-26T00:10:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcFo8",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:11:26Z",
          "updatedAt": "2022-01-26T00:11:28Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Yeah I have seen some other repos that include the ability to do this locally to preview changes in final output form, was going to tackle in a follow up PR",
              "createdAt": "2022-01-26T00:11:27Z",
              "updatedAt": "2022-01-26T00:11:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcGTB",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:17:20Z",
          "updatedAt": "2022-01-26T00:17:20Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Have updated this workflow file essentially it is designed to be run once then deletes it self, just sets up tooling around the draft publication",
              "createdAt": "2022-01-26T00:17:20Z",
              "updatedAt": "2022-01-26T00:17:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOF8lax84zcGWE",
          "commit": {
            "abbreviatedOid": "1fe6a92"
          },
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T00:17:43Z",
          "updatedAt": "2022-01-26T00:17:43Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "Note as above this workflow is just designed to be run once also",
              "createdAt": "2022-01-26T00:17:43Z",
              "updatedAt": "2022-01-26T00:17:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 35,
      "id": "PR_kwDOF8lax84xmKrD",
      "title": "Remove deterministic public key section from the spec",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/35",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Regardless of the outcome of #19 most in the group appear to agree that generators should always be considered an internal cryptographic structure instead of one that forces API consumers to manage externally, with that in mind we can remove any mention of deterministic public keys vs short form public keys and instead simplify to have only 1 type.\r\n\r\nFixes #26 ",
      "createdAt": "2022-01-26T04:49:12Z",
      "updatedAt": "2022-01-26T22:37:20Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "b49728ecb6ec3166ed095151a056869f8a3019f0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/remove-deterministic-public-key",
      "headRefOid": "bb79edaccb75da28a3fb006db3435b7f286067e2",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "`PK` has two generation paths with equivalent output. What happens with `PK` generation when `SK` isn't available, e.g. by a verifier?",
          "createdAt": "2022-01-26T15:43:44Z",
          "updatedAt": "2022-01-26T15:43:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "MEMBER",
          "body": "@tmarkovski can you clarify when SK is not available what other option there is to generate PK?",
          "createdAt": "2022-01-26T21:59:41Z",
          "updatedAt": "2022-01-26T21:59:41Z"
        },
        {
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "body": "I misunderstood the initial intent. You're basically suggesting we turn DPK into PK, and hide the generator construction internal the implementation, since these keys don't need to managed externally anyway.",
          "createdAt": "2022-01-26T22:29:33Z",
          "updatedAt": "2022-01-26T22:29:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOF8lax84zgngW",
          "commit": {
            "abbreviatedOid": "bb79eda"
          },
          "author": "tmarkovski",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-26T22:37:20Z",
          "updatedAt": "2022-01-26T22:37:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOF8lax84xmrdL",
      "title": "Rename nonce to presentation message",
      "url": "https://github.com/decentralized-identity/bbs-signature/pull/36",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Implements the suggestion documented in issue #33 ",
      "createdAt": "2022-01-26T09:09:20Z",
      "updatedAt": "2022-01-26T09:09:20Z",
      "baseRepository": "decentralized-identity/bbs-signature",
      "baseRefName": "main",
      "baseRefOid": "b49728ecb6ec3166ed095151a056869f8a3019f0",
      "headRepository": "decentralized-identity/bbs-signature",
      "headRefName": "tl/nonce-presentation-message",
      "headRefOid": "28b0aaa9a27a65a125a12b630e84efbdcf8d40ad",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}